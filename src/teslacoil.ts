/* eslint-disable */

import axios from 'axios'

const api = axios.create({
  validateStatus: () => true,
})

const apiKeyNotSetMessage = "looks like you haven't set your api-key! set api-key by calling setCredentials(key)"
type environments = 'MAINNET' | 'TESTNET' | 'REGTEST'
let apiKey = ''

export const setCredentials = (key: string, network: environments = 'REGTEST'): void => {
  if (key === '') {
    throw Error('api key can not be set to empty string')
  }

  apiKey = key
  switch (network) {
    case 'MAINNET':
      api.defaults.baseURL = 'https://api.teslacoil.io'
      break
    case 'TESTNET':
      api.defaults.baseURL = 'https://testnetapi.teslacoil.io'
      break
    case 'REGTEST':
      api.defaults.baseURL = 'http://localhost:5000'
      break
  }
  api.defaults.timeout = 5000
  api.defaults.headers = { Authorization: apiKey }
}

/* Generated by restful-react */

export interface Account {
  auto_exchange_currency?: FiatcurrencyFiatCurrency
  balance_bitcoin?: number
  balance_satoshi?: string
  id?: string
  name?: string
}

/**
 * Information describing a user and its relation to an account.
 */
export interface AccountUser {
  account_id: string
  account_name: string
  admin: boolean
  auto_exchange_currency: FiatcurrencyFiatCurrency
  balance_bitcoin: number
  balance_satoshi: string
  create_time: string
  email: string
  first_name: string
  has_changed_password: boolean
  has_confirmed_2fa: boolean
  last_login_time: string
  last_name: string
  owner: boolean
  permissions: Permissions
  update_time: string
  user_id: string
  user_preferred_display_currency: CryptoCurrencyFormat
}

export interface AccountingTransaction {
  complete_time?: string
  direction?: TransactionDirection
  id?: string
  inbound_milli_sat?: string
  invoice_description?: string
  invoice_id?: string
  memo?: string
  network_fee_milli_sat?: string
  network_type?: NetworkType
  outbound_milli_sat?: string
  transaction_description?: string
}

export interface ApiKey {
  account_id: string
  create_time: string
  /**
   * The description (if any) associated with this key.
   */
  description: string
  expiry_time?: string
  /**
   * The hashed API key. API keys are not stored in cleartext in the database,
   * but compared against a hash. The user is only shown their API key once, and
   * Teslacoil is unable to retrieve it in cleartext again.
   */
  hashed_key: string
  /**
   * The last letters of the API key. This is stored so it is easier to
   * identify a specific key in a list of all keys.
   */
  last_letters: string
  last_use_time?: string
  permissions: Permissions
  whitelisted_ips: string[]
}

/**
 * Description of event that triggered callback
 */
export type CallbackEvent = string

/**
 * Identifier for callback types
 */
export type CallbackIdentifier =
  | 'lightning-invoice'
  | 'onchain-invoice'
  | 'onchain-transaction'
  | 'lightning-transaction'

export interface ChangePasswordRequest {
  /**
   * The new user password. This is a required field.
   */
  new_password: string
  /**
   * The old user password. This is a required field.
   */
  old_password: string
  /**
   * The new user password, again. This field should be populated with the text
   * from a different field than the first new password. This is a required
   * field.
   */
  repeated_new_password: string
}

export interface CompleteLNURLWithdrawResponse {
  transaction_id?: string
}

export interface Confirm2faRequest {
  /**
   * A 2FA code the user generated with their authenticator app. This is a
   * required field.
   */
  code: string
}

export interface Create2faResponse {
  /**
   * A 2FA secret the user can input into their authenticator app to
   * generate 2FA codes.
   */
  totp_secret: string
}

export interface CreateAccountRequest {
  name: string
}

export interface CreateApiKeyRequest {
  /**
   * An optional description of your API key. We highly recommend including
   * this, as it makes it much easier to identify a specific key later on.
   */
  description?: string
  expiry_time?: string
  permissions?: Permissions
  whitelisted_ips?: string[]
}

export interface CreateApiKeyResponse {
  key: string
  key_information: ApiKey
}

/**
 * The available fields for creating an invoice.
 */
export interface CreateInvoiceRequest {
  /**
   * The amount you want your created invoice to be for, measured in the
   * currency you specify.
   * This is a required field, and cannot be less than or equal to zero.
   */
  amount?: number
  /**
   * An (optional) callback URL to associate with this invoice. When the
   * invoice receives payment, we send a POST request to this URL to notify
   * you.
   */
  callback_url?: string
  /**
   * An (optional) ID you can associate with this invoice. This is never
   * used by Teslacoil, other than to identify your invoice when notifying
   * you of updates, as well as letting you retrieve the invoice by this ID.
   * We wont validate that this ID is unique to your invoice. So if you
   * want to use this field to later retrieve an invoice, you will have to
   * make sure yourself that it only identifies a single element.
   */
  client_id?: string
  currency?: CurrencyCurrency
  /**
   * An (optional) description to associate with this invoice. This is only
   * visible to the creator of the invoice.
   */
  description?: string
  exchange_currency?: FiatcurrencyFiatCurrency
  /**
   * The expiry of this invoice. Defaults to 1 hour, if not
   * set or set to zero. It is still possible for the user to send money to the
   * address associated with this invoice, but it will not make it count as
   * settled.
   */
  expiry_seconds?: number
  /**
   * An optional description to encode into the Lightning request
   * associated with this invoice. This is publicly visible. If creating an
   * on-chain invoice, setting this field has no effect.
   */
  lightning_memo?: string
}

export interface CreateLNURLWithdrawRequest {
  custom_complete_url?: string
  /**
   * if set, will make sure the lnurl withdrawal can't be completed after a set
   * time defaults to 3600 (1 hour).
   */
  expiry_seconds?: number
  /**
   * An optional description used to request the caller of this request to
   * encode this field in the generated lightning request.
   */
  lightning_request_memo?: string
  max_withdrawable_milli_satoshi?: string
  /**
   * Minimum amount allowed to withdraw using the generated secret. If not set,
   * defaults to 0.
   */
  min_withdrawable_milli_satoshi?: string
}

/**
 * Contains all necessary information to show a lnurl withdrawal QR code to the
 * user.
 */
export interface CreateLNURLWithdrawResponse {
  k1_secret?: string
  /**
   * An encoded lnurl containing a link to GET more information about the
   * withdrawal, including the secret.
   */
  lnurl?: string
}

export interface CreateUserRequest {
  /**
   * The email of the user you want to create. This is a required field. After
   * the user is created, we'll send a message to this email address. The user
   * will then have to verify their address by clicking on a link in said email.
   * Until this is done, the user cannot sign in or otherwise use Teslacoil.
   * Until the user has activated 2FA and changed their password, it only has
   * very limited access to teslacoil.
   */
  email?: string
  first_name?: string
  last_name?: string
}

/**
 * - BITCOIN: Whole units of bitcoin
 *  - SATOSHIS: 1/100 000 000 of a bitcoin
 */
export type CryptoCurrencyFormat = 'BITCOIN' | 'SATOSHIS'

export interface CurrenciesConvertResponse {
  /**
   * amount is the quote amount per base amount.
   */
  amount: number
  base_currency: CurrencyCurrency
  quote_currency: CurrencyCurrency
}

export interface CurrenciesQuoteResponse {
  amount_btc: number
  amount_satoshi: number
  base_currency: CurrencyCurrency
  quote_currency: CurrencyCurrency
  rate: number
}

export interface DecodeLightningResponse {
  amount_satoshi?: string
  destination?: string
  expire_time?: string
  fallback_onchain_address?: string
  memo?: string
  /**
   * The hash of the preimage.
   */
  payment_hash?: string
}

export interface EstimateBlockchainFeesResponse {
  average_fee: number
  currency: CurrencyCurrency
  sats_per_byte: number
}

export interface EstimateLightningFeesResponse {
  currency: CurrencyCurrency
  fee: number
}

export interface GetJwtRequest {
  /**
   * The ID or name of the account that the JWT will be valid for. If not set,
   * the JWT is only valid for certain user-related endpoints.
   */
  account_identifier?: string
  /**
   * The email of the user that's requesting a JWT. This is a required field.
   */
  email: string
  /**
   * The password of the user that's requesting a JWT. This is a required field.
   */
  password: string
  /**
   * The 2FA code to use when requesting a JWT. If 2FA is enabled, this is a
   * required field.
   */
  totp_code?: string
}

export interface GetJwtResponse {
  /**
   * The created JWT. This can be used to authenticate against the API, by
   * prefixing it with "Bearer " and placing in the authorization header.
   */
  token: string
}

export interface GiveAccessRequest {
  permissions?: Permissions
  user_id?: string
}

/**
 * An invoice that contains all the fields that a Lightning and an on-chain
 * invoice has in common. It also contains a type parameter which indicates
 * whether it is a Lightning invoice or an on-chain invoice.
 */
export interface Invoice {
  account_id: string
  bitcoin_address: string
  /**
   * The callback URL associated with this invoice, if any.
   */
  callback_url: string
  /**
   * An (optional) ID you associated with this invoice. This is never
   * used by Teslacoil, other than to identify your invoice when notifying
   * you of updates, as well as letting you retrieve the transaction by this
   * ID. We wont validate that this ID is unique to your invoices. So if you
   * want to use this field to later retrieve a invoice, you will have to
   * make sure yourself that it only identifies a single element.
   */
  client_id: string
  /**
   * When this invoice was created.
   */
  create_time: string
  /**
   * The description associated with this invoice, if any.
   */
  description: string
  exchange_currency: FiatcurrencyFiatCurrency
  /**
   * How long this invoice is valid for, measured in seconds. If this invoice
   * has an associated Lightning request, it is not to possible to pay
   * it after the invoice is expired. If it has a bitcoin address associated
   * with it, it is
   *  still possible to send money to the associated bitcoin address after the
   *  invoices is expired, but it will not cause the invoice to become settled.
   */
  expiry_seconds: number
  fiat_currency: FiatcurrencyFiatCurrency
  id: string
  lightning_payment_request: string
  paid_before_expiry: boolean
  payment_status: InvoiceStatus
  requested_amount_bitcoin: number
  requested_amount_fiat: number
  requested_amount_satoshi: string
  /**
   * When this invoice was settled, if at all.
   */
  settle_time: string
  /**
   * The IDs of the transaction that settled this invoice. Length is 0 if the
   * invoice isn't settled.
   */
  transaction_ids: string[]
  type: NetworkType
}

export interface InvoiceList {
  invoices: Invoice[]
  total: number
}

/**
 * - UNPAID: The invoice has not received a payment
 *  - PAID: This invoice has received a payment for the exact amount we expected
 *  - OVERPAID: Money was sent, but more than we expected. The invoice can be considered
 * settled
 *  - UNDERPAID: Money was sent, but less than we expected. The invoice is not considered
 * settled.
 */
export type InvoiceStatus = 'UNPAID' | 'PAID' | 'OVERPAID' | 'UNDERPAID'

/**
 * Contains all necessary information to prefill the users wallet with info, and
 * complete the withdrawal.
 */
export interface LNURLWithdrawResponse {
  callback?: string
  defaultDescription?: string
  k1?: string
  maxWithdrawable?: string
  minWithdrawable?: string
  tag?: string
}

export interface LightningTransaction {
  amount_bitcoin: number
  amount_satoshi: string
  /**
   * The URL to hit when the status of this transaction changes.
   */
  callback_url: string
  /**
   * Every transaction can have a client ID associated to it. This is not used
   * by Teslacoil, but can be used to correlate transactions with your internal
   * database when handling callbacks and other interactions with the Teslacoil
   * API.
   */
  client_id: string
  /**
   * The creation time of this transaction.
   */
  create_time: string
  /**
   * An internal description associated with this transaction. This is only
   * visible to the creator of the transaction.
   */
  description: string
  direction: TransactionDirection
  /**
   * The hashed preimage of this transaction.
   */
  hashed_preimage: string
  id: string
  invoice_id: string
  /**
   * The encoded payment request description of this transaction. This is
   * encoded into the payment request, and is publicly visible.
   */
  memo: string
  network_fee_bitcoin: number
  network_fee_satoshi: string
  /**
   * If the lightning payment failed, this field specifies why this happened.
   */
  payment_error: string
  /**
   * The payment request belonging to this transactions. All Lightning
   * transactions have a payment request associated with them. Payment requests
   * specify the recipient and amount of a transaction, as well as other,
   * optional, information.
   */
  payment_request: string
  /**
   * The preimage of this transaction, if any. Preimages for transactions are
   * only available if they are settled.
   */
  preimage: string
  /**
   * The settlement time of this transaction. This is only available for
   * completed transactions.
   */
  settlement_time: string
  status: TransactionStatus
}

export interface ListAccountNamesResponse {
  names: string[]
}

export interface ListAccountsResponse {
  accounts: Account[]
}

export interface ListApiKeysResponse {
  keys: ApiKey[]
}

export interface ListSettlementsResponse {
  settlements: Settlement[]
  total: number
}

export interface ListTradesResponse {
  total: number
  trades: Trade[]
}

export interface ListTransactionsResponse {
  /**
   * How many transactions matched the filtering options sent. Can be used to
   * implement pagination client-side.
   */
  total: number
  transactions: Transaction[]
}

/**
 * - ONCHAIN: A transaction made on the Bitcoin blockchain
 *  - LIGHTNING: A transaction sent on the Lightning Network
 */
export type NetworkType = 'ONCHAIN' | 'LIGHTNING'

export interface OnchainTransaction {
  /**
   * The address this transaction was sent to. If this is an outgoing
   * transaction, this is the recipient. If this as incoming, it is our deposit
   * address.
   */
  address: string
  /**
   * How much this transaction was for, i.e. how much it credited/debited the
   * account. Measured in bitcoin.
   */
  amount_bitcoin: number
  /**
   * How much this transaction was for, i.e. how much it credited/debited the
   * account. Measured in satoshis.
   */
  amount_satoshi: string
  /**
   * The URL, if any, to send updates to whenever events related to this
   * transaction occurs.
   */
  callback_url: string
  /**
   * Every transaction can have a client ID associated to it. This is not used
   * by Teslacoil, but can be used to correlate transactions with your internal
   * database when handling callbacks and other interactions with the Teslacoil
   * API.
   */
  client_id: string
  /**
   * If this transaction is confirmed, this is the block height that the
   * transaction was confirmed at.
   */
  confirmation_block_height: string
  /**
   * If this transaction is confirmed, this is the time that the transaction was
   * confirmed.
   */
  confirmation_time: string
  /**
   * Whether or not this transaction has been confirmed by being placed into the
   * Bitcoin blockchain. This does not happen immediately after a transaction is
   * made, because a Bitcoin miner needs to process it first.
   */
  confirmed: boolean
  /**
   * When this transaction was created.
   */
  create_time: string
  description: string
  direction: TransactionDirection
  /**
   * The internal Teslacoil ID of this transaction. Can be used to retrieve the
   * transaction at a later point in time.
   */
  id: string
  invoice_id: string
  /**
   * How much fees we paid to the bitcoin miners for this transaction. Not set
   * if this transaction was sent to us, as we can't know that.
   */
  network_fee_bitcoin: number
  /**
   * How much fees we paid to the bitcoin miners for this transaction. Not set
   * if this transaction was sent to us, as we can't know that.
   */
  network_fee_satoshi: string
  /**
   * The Bitcoin network transaction ID of this transaction. This can be used to
   * look up the transaction in a block explorer or a Bitcoin node.
   */
  transaction_id: string
  /**
   * The output index of the underlying Bitcoin transaction that this specfic
   * transfer of funds refer to.
   */
  transaction_output: string
}

/**
 * The valid sides for a trade. Used in getting a RFQ (request for quote), and
 * creating and describing trades.
 *
 *  - BUY: Buy bitcoin
 *  - SELL: Sell bitcoin
 */
export type OrderSide = 'BUY' | 'SELL'

export interface Permissions {
  accounting: Privileges
  accounts: Privileges
  api_keys: Privileges
  auth: Privileges
  currencies: Privileges
  exchange: Privileges
  experimental: Privileges
  invoices: Privileges
  system: Privileges
  transactions: Privileges
  users: Privileges
}

export interface Privileges {
  create: boolean
  delete: boolean
  read: boolean
  update: boolean
}

export interface ResetPasswordRequest {
  /**
   * The users password. This is a required field.
   */
  password?: string
  /**
   * The users password resset token, obtained through requesting one being sent
   * to the users email. This is a required field.
   */
  token?: string
}

export interface RestError {
  error?: RestErrorContent
}

export interface RestErrorContent {
  details?: { [key: string]: any }[]
  docs?: string
  message?: string
  status?: string
}

export interface RiskLimitsResponse {
  [key: string]: any
}

export interface SendLightningRequest {
  /**
   * The URL we send a POST request to when the transaction is completed.
   */
  callback_url?: string
  /**
   * An (optional) ID you associated with this transaction. This is never
   * used by Teslacoil, other than to identify your transaction when notifying
   * you of updates, as well as letting you retrieve the transaction by this
   * ID. We wont validate that this ID is unique to your transaction. So if you
   * want to use this field to later retrieve a transaction, you will have to
   * make sure yourself that it only identifies a single element.
   */
  client_id?: string
  /**
   * An optional description to associate with this transaction. This is only
   * visible to the sender of this request.
   */
  description?: string
  payment_request?: string
}

export interface SendOnchainRequest {
  /**
   * The destination bitcoin address. Must be set.
   */
  address?: string
  amount?: number
  /**
   * The URL, if any, to send updates to whenever events related to this
   * transaction occurs.
   */
  callback_url?: string
  /**
   * An (optional) ID you can associate with this transaction. This is never
   * used by Teslacoil, other than to identify your transaction when notifying
   * you of updates, as well as letting you retrieve the transaction by this ID.
   * We wont validate that this ID is unique to your transactions. So if you
   * want to use this field to later retrieve a transaction, you will have to
   * make sure yourself that it only identifies a single element.
   */
  client_id?: string
  currency?: CurrencyCurrency
  /**
   * An (optional) description to associate with this transaction. Only visible
   * to the sender of the transaction.
   */
  description?: string
  /**
   * If set, we use this as the fee rate for your transaction, measured in
   * satoshi per (virtual) byte.
   */
  fee_satoshi_per_byte?: number
  /**
   * If set, sends all the funds in the wallet. Cannot be specified together
   * with a monetary amount.
   */
  send_all?: boolean
  /**
   * If set, we try and construct the transaction such that it is confirmed by
   * this number of blocks. A higher value here means a lower network fee, but
   * you will have to wait longer until the transaction is included in the
   * blockchain. A lower value would make your transaction confirm quicked, but
   * it would be more expensive.
   */
  target_confirmation?: number
}

export interface SendPasswordResetEmailRequest {
  /**
   * The email the user signed up with. This is a required field.
   */
  email?: string
}

export interface SendTransactionRequest {
  /**
   * The destination bitcoin address. If this set, you must also set the amount
   * and currency. Cannot be set together with a Lightning payment requests.
   */
  address?: string
  amount?: number
  callback_url?: string
  /**
   * An (optional) ID you associated with this invoice. This is never
   * used by Teslacoil, other than to identify your invoice when notifying
   * you of updates, as well as letting you retrieve the transaction by this
   * ID. We wont validate that this ID is unique to your invoices. So if you
   * want to use this field to later retrieve a invoice, you will have to
   * make sure yourself that it only identifies a single element.
   */
  client_id?: string
  currency?: CurrencyCurrency
  /**
   * An optional description to associate with this transaction. This is only
   * visible to the sender of this request.
   */
  description?: string
  payment_request?: string
}

/**
 * The fields returned when a transaction was successfully initiated.
 * It does not include specific information about the transaction for security
 * purposes, as there are several steps payment must go through before it is
 * sent which might take some time. You can poll for the latest updates using
 * the provided url.
 */
export interface SendTransactionResponse {
  id?: string
  url?: string
}

/**
 * A settlement represents the finalization of trades performed at a prior time.
 * The parties transfer funds to each other to settle their debts.
 */
export interface Settlement {
  amount?: number
  create_time?: string
  currency?: CurrencyCurrency
  direction?: TransactionDirection
  /**
   * Whether or not this settlement is considered finished. It is considered
   * finished if all parties have sent and received the sums agreed upon.
   */
  done?: boolean
  /**
   * When, if any, this settlement was finalized.
   */
  finalize_time?: string
  id?: string
  transactions?: Transaction[]
}

/**
 * - DESCENDING: Sort transactions descending, chronologically
 *  - ASCENDING: Sort transactions ascending, chronologically
 */
export type SortingDirection = 'DESCENDING' | 'ASCENDING'

export interface Statement {
  account_id?: string
  closing_balance_milli_sat?: string
  end_time?: string
  inbound_milli_sat?: string
  network_fee_milli_sat?: string
  opening_balance_milli_sat?: string
  outbound_milli_sat?: string
  start_time?: string
  transactions?: AccountingTransaction[]
}

export interface Trade {
  amount_base: number
  amount_quote: number
  base: CurrencyCurrency
  create_time: string
  id: string
  quote: CurrencyCurrency
  rate: number
  side: OrderSide
}

export interface Transaction {
  account_id: string
  amount_bitcoin: number
  amount_satoshi: string
  /**
   * The URL, if any, to send updates to whenever events related to this
   * transaction occurs.
   */
  callback_url: string
  client_id: string
  create_time: string
  description: string
  direction: TransactionDirection
  id: string
  invoice_id: string
  network_fee_bitcoin: number
  network_fee_satoshi: string
  network_type: NetworkType
  status: TransactionStatus
}

/**
 * - INCOMING: Received to Teslacoil, a deposit
 *  - OUTGOING: Sent from Teslacoil, a withdrawal
 */
export type TransactionDirection = 'INCOMING' | 'OUTGOING'

/**
 * - PENDING: The transaction has not reached a conclusion whether it's completed or
 * failed yet
 *  - COMPLETED: The transaction has been received by the recipient, and is settled.
 *  - FAILED: The transaction has failed
 */
export type TransactionStatus = 'PENDING' | 'COMPLETED' | 'FAILED'

export interface UpdateAccessRequest {
  new_permissions?: Permissions
  user_id?: string
}

export interface UpdateAccountRequest {
  new_auto_exchange_currency?: FiatcurrencyFiatCurrency
  new_name?: string
  new_permissions?: Permissions
}

export interface UpdateUserRequest {
  first_name?: string
  last_name?: string
  preferred_display_currency?: CryptoCurrencyFormat
}

export interface User {
  email: string
  first_name: string
  id: string
  last_name: string
  preferred_crypto_display_currency: CryptoCurrencyFormat
}

/**
 * ISO 4217: alpha 3-letter e.g EUR, BTC.
 *
 *  - BTC: BTC is the ticker for bitcoin
 *  - SAT: SAT is the smallest denominator of 1 BTC, and is equal to 1/100_000_000
 * of 1 BTC.
 */
export type CurrencyCurrency = 'BTC' | 'SAT' | 'GBP' | 'NOK' | 'USD' | 'EUR'

export type FiatcurrencyFiatCurrency = 'GBP' | 'NOK' | 'USD' | 'EUR'

/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a
 * URL that describes the type of the serialized message.
 *
 * Protobuf library provides support to pack/unpack Any values in the form
 * of utility functions or additional generated methods of the Any type.
 *
 * Example 1: Pack and unpack a message in C++.
 *
 *     Foo foo = ...;
 *     Any any;
 *     any.PackFrom(foo);
 *     ...
 *     if (any.UnpackTo(&foo)) {
 *       ...
 *     }
 *
 * Example 2: Pack and unpack a message in Java.
 *
 *     Foo foo = ...;
 *     Any any = Any.pack(foo);
 *     ...
 *     if (any.is(Foo.class)) {
 *       foo = any.unpack(Foo.class);
 *     }
 *
 *  Example 3: Pack and unpack a message in Python.
 *
 *     foo = Foo(...)
 *     any = Any()
 *     any.Pack(foo)
 *     ...
 *     if any.Is(Foo.DESCRIPTOR):
 *       any.Unpack(foo)
 *       ...
 *
 *  Example 4: Pack and unpack a message in Go
 *
 *      foo := &pb.Foo{...}
 *      any, err := ptypes.MarshalAny(foo)
 *      ...
 *      foo := &pb.Foo{}
 *      if err := ptypes.UnmarshalAny(any, foo); err != nil {
 *        ...
 *      }
 *
 * The pack methods provided by protobuf library will by default use
 * 'type.googleapis.com/full.type.name' as the type URL and the unpack
 * methods only use the fully qualified type name after the last '/'
 * in the type URL, for example "foo.bar.com/x/y.z" will yield type
 * name "y.z".
 *
 *
 * JSON
 * ====
 * The JSON representation of an `Any` value uses the regular
 * representation of the deserialized, embedded message, with an
 * additional field `@type` which contains the type URL. Example:
 *
 *     package google.profile;
 *     message Person {
 *       string first_name = 1;
 *       string last_name = 2;
 *     }
 *
 *     {
 *       "@type": "type.googleapis.com/google.profile.Person",
 *       "firstName": <string>,
 *       "lastName": <string>
 *     }
 *
 * If the embedded message type is well-known and has a custom JSON
 * representation, that representation will be embedded adding a field
 * `value` which holds the custom JSON in addition to the `@type`
 * field. Example (for message [google.protobuf.Duration][]):
 *
 *     {
 *       "@type": "type.googleapis.com/google.protobuf.Duration",
 *       "value": "1.212s"
 *     }
 */
export interface ProtobufAny {
  /**
   * A URL/resource name that uniquely identifies the type of the serialized
   * protocol buffer message. The last segment of the URL's path must represent
   * the fully qualified name of the type (as in
   * `path/google.protobuf.Duration`). The name should be in a canonical form
   * (e.g., leading "." is not accepted).
   *
   * In practice, teams usually precompile into the binary all types that they
   * expect it to use in the context of Any. However, for URLs which use the
   * scheme `http`, `https`, or no scheme, one can optionally set up a type
   * server that maps type URLs to message definitions as follows:
   *
   * * If no scheme is provided, `https` is assumed.
   * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
   *   value in binary format, or produce an error.
   * * Applications are allowed to cache lookup results based on the
   *   URL, or have them precompiled into a binary to avoid any
   *   lookup. Therefore, binary compatibility needs to be preserved
   *   on changes to types. (Use versioned type names to manage
   *   breaking changes.)
   *
   * Note: this functionality is not currently available in the official
   * protobuf release, and it is not used for type URLs beginning with
   * type.googleapis.com.
   *
   * Schemes other than `http`, `https` (or the empty scheme) might be
   * used with implementation specific semantics.
   */
  type_url?: string
  /**
   * Must be a valid serialized protocol buffer of the above specified type.
   */
  value?: string
}

export interface RuntimeError {
  code?: number
  details?: ProtobufAny[]
  error?: string
  message?: string
}

// tslint:disable-next-line:no-empty-interface
export interface AuthenticationCreate2faBodyRequestBody {}

export type CreateInvoiceRequestRequestBody = CreateInvoiceRequest

const buildURL = (...args: any[]): string => {
  let url = ''
  args.forEach(arg => {
    if (arg) {
      if (url === '') {
        url += `?${arg}=\${${arg}}`
      } else {
        url += `&${arg}=\${${arg}}`
      }
    }
  })
  return `${url}`
}

export const Accounting_GetStatement = async (start_time?: string, end_time?: string): Promise<Statement> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.get(
      `/v0/accounting/statement${buildURL(start_time && 'start_time', end_time && 'end_time')}`
    )
    return response.data as Statement
  } catch (error) {
    throw Error(error)
  }
}

export const Accounts_Get = async (): Promise<Account> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.get(`/v0/accounts`)
    return response.data as Account
  } catch (error) {
    throw Error(error)
  }
}

export const Accounts_Create = async (req: CreateAccountRequest): Promise<Account> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.post('/v0/accounts', req)
    return response.data as Account
  } catch (error) {
    throw Error(error)
  }
}

export const Accounts_Update = async (req: UpdateAccountRequest): Promise<Account> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.put('/v0/accounts', req)
    return response.data as Account
  } catch (error) {
    throw Error(error)
  }
}

export const Accounts_RemoveAccess = async (user_id?: string): Promise<{}> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.delete(`/v0/accounts/access${buildURL(user_id && 'user_id')}`)
    return response.data as {}
  } catch (error) {
    throw Error(error)
  }
}

export const Accounts_UpdateAccess = async (req: UpdateAccessRequest): Promise<{}> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.post('/v0/accounts/access', req)
    return response.data as {}
  } catch (error) {
    throw Error(error)
  }
}

export const Accounts_GiveAccess = async (req: GiveAccessRequest): Promise<{}> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.put('/v0/accounts/access', req)
    return response.data as {}
  } catch (error) {
    throw Error(error)
  }
}

export const Accounts_List = async (): Promise<ListAccountsResponse> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.get(`/v0/accounts/list`)
    return response.data as ListAccountsResponse
  } catch (error) {
    throw Error(error)
  }
}

export const Accounts_ListAccountNames = async (): Promise<ListAccountNamesResponse> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.get(`/v0/accounts/names`)
    return response.data as ListAccountNamesResponse
  } catch (error) {
    throw Error(error)
  }
}

export const Accounts_GetUserInfo = async (user_id?: string): Promise<AccountUser> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.get(`/v0/accounts/user${buildURL(user_id && 'user_id')}`)
    return response.data as AccountUser
  } catch (error) {
    throw Error(error)
  }
}

export const ApiKeys_Delete = async (hash?: string): Promise<ApiKey> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.delete(`/v0/apikeys${buildURL(hash && 'hash')}`)
    return response.data as ApiKey
  } catch (error) {
    throw Error(error)
  }
}

export const ApiKeys_Get = async (hash?: string): Promise<ApiKey> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.get(`/v0/apikeys${buildURL(hash && 'hash')}`)
    return response.data as ApiKey
  } catch (error) {
    throw Error(error)
  }
}

export const ApiKeys_Create = async (req: CreateApiKeyRequest): Promise<CreateApiKeyResponse> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.post('/v0/apikeys', req)
    return response.data as CreateApiKeyResponse
  } catch (error) {
    throw Error(error)
  }
}

export const ApiKeys_List = async (): Promise<ListApiKeysResponse> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.get(`/v0/apikeys/list`)
    return response.data as ListApiKeysResponse
  } catch (error) {
    throw Error(error)
  }
}

export const Authentication_ChangePassword = async (req: ChangePasswordRequest): Promise<{}> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.put('/v0/auth/change_password', req)
    return response.data as {}
  } catch (error) {
    throw Error(error)
  }
}

export const Authentication_Confirm2fa = async (req: Confirm2faRequest): Promise<{}> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.put('/v0/auth/confirm_2fa', req)
    return response.data as {}
  } catch (error) {
    throw Error(error)
  }
}

export const Authentication_Create2fa = async (): Promise<Create2faResponse> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.post('/v0/auth/create_2fa')
    return response.data as Create2faResponse
  } catch (error) {
    throw Error(error)
  }
}

export const Authentication_GetJwt = async (req: GetJwtRequest): Promise<GetJwtResponse> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.post('/v0/auth/get_jwt', req)
    return response.data as GetJwtResponse
  } catch (error) {
    throw Error(error)
  }
}

export const Authentication_RefreshJwt = async (): Promise<GetJwtResponse> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.get(`/v0/auth/refresh_jwt`)
    return response.data as GetJwtResponse
  } catch (error) {
    throw Error(error)
  }
}

export const Authentication_ResetPassword = async (req: ResetPasswordRequest): Promise<{}> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.put('/v0/auth/reset_password', req)
    return response.data as {}
  } catch (error) {
    throw Error(error)
  }
}

export const Authentication_SendPasswordResetEmail = async (req: SendPasswordResetEmailRequest): Promise<{}> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.post('/v0/auth/send_password_reset_email', req)
    return response.data as {}
  } catch (error) {
    throw Error(error)
  }
}

export const Currencies_Convert = async (
  base_currency?: string,
  quote_currency?: string,
  amount?: number
): Promise<CurrenciesConvertResponse> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.get(
      `/v0/currencies/convert${buildURL(
        base_currency && 'base_currency',
        quote_currency && 'quote_currency',
        amount && 'amount'
      )}`
    )
    return response.data as CurrenciesConvertResponse
  } catch (error) {
    throw Error(error)
  }
}

export const Currencies_Quote = async (
  side?: string,
  amount?: number,
  currency?: string
): Promise<CurrenciesQuoteResponse> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.get(
      `/v0/currencies/quote${buildURL(side && 'side', amount && 'amount', currency && 'currency')}`
    )
    return response.data as CurrenciesQuoteResponse
  } catch (error) {
    throw Error(error)
  }
}

export const Exchange_RiskLimits = async (): Promise<RiskLimitsResponse> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.get(`/v0/exchange/limits`)
    return response.data as RiskLimitsResponse
  } catch (error) {
    throw Error(error)
  }
}

export const Exchange_ListSettlements = async (): Promise<ListSettlementsResponse> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.get(`/v0/exchange/settlement/list`)
    return response.data as ListSettlementsResponse
  } catch (error) {
    throw Error(error)
  }
}

export const Exchange_ListTrades = async (
  offset?: number,
  limit?: number,
  max_satoshi?: string,
  min_satoshi?: string,
  start_time?: string,
  end_time?: string,
  sort: 'DESCENDING' | 'ASCENDING' = 'DESCENDING',
  side?: string
): Promise<ListTradesResponse> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.get(
      `/v0/exchange/trades/list${buildURL(
        offset && 'offset',
        limit && 'limit',
        max_satoshi && 'max_satoshi',
        min_satoshi && 'min_satoshi',
        start_time && 'start_time',
        end_time && 'end_time',
        sort && 'sort',
        side && 'side'
      )}`
    )
    return response.data as ListTradesResponse
  } catch (error) {
    throw Error(error)
  }
}

export const Experimental_GetLNURLWithdrawal = async (secret?: string): Promise<LNURLWithdrawResponse> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.get(`/v0/experimental/lnurl/withdraw${buildURL(secret && 'secret')}`)
    return response.data as LNURLWithdrawResponse
  } catch (error) {
    throw Error(error)
  }
}

export const Experimental_CompleteLNURLWithdraw = async (
  k1?: string,
  pr?: string,
  transaction_callback_url?: string
): Promise<CompleteLNURLWithdrawResponse> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.get(
      `/v0/experimental/lnurl/withdraw/complete${buildURL(
        k1 && 'k1',
        pr && 'pr',
        transaction_callback_url && 'transaction_callback_url'
      )}`
    )
    return response.data as CompleteLNURLWithdrawResponse
  } catch (error) {
    throw Error(error)
  }
}

export const Experimental_CreateLNURLWithdraw = async (
  req: CreateLNURLWithdrawRequest
): Promise<CreateLNURLWithdrawResponse> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.post('/v0/experimental/lnurl/withdraw/create', req)
    return response.data as CreateLNURLWithdrawResponse
  } catch (error) {
    throw Error(error)
  }
}

export const Fees_EstimateBlockchainFees = async (
  target?: number,
  currency?: string
): Promise<EstimateBlockchainFeesResponse> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.get(
      `/v0/fees/estimate/blockchain${buildURL(target && 'target', currency && 'currency')}`
    )
    return response.data as EstimateBlockchainFeesResponse
  } catch (error) {
    throw Error(error)
  }
}

export const Fees_EstimateLightningFees = async (
  payment_request?: string,
  currency?: string
): Promise<EstimateLightningFeesResponse> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.get(
      `/v0/fees/estimate/lightning${buildURL(payment_request && 'payment_request', currency && 'currency')}`
    )
    return response.data as EstimateLightningFeesResponse
  } catch (error) {
    throw Error(error)
  }
}

export const Invoices_Get = async (
  id?: string,
  transaction_id?: string,
  address?: string,
  payment_request?: string
): Promise<Invoice> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.get(
      `/v0/invoices${buildURL(
        id && 'id',
        transaction_id && 'transaction_id',
        address && 'address',
        payment_request && 'payment_request'
      )}`
    )
    return response.data as Invoice
  } catch (error) {
    throw Error(error)
  }
}

export const Invoices_CreateLightning = async (req: CreateInvoiceRequest): Promise<Invoice> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.post('/v0/invoices/lightning', req)
    return response.data as Invoice
  } catch (error) {
    throw Error(error)
  }
}

export const Invoices_List = async (
  offset?: number,
  limit?: number,
  max_satoshi?: string,
  min_satoshi?: string,
  start_time?: string,
  end_time?: string,
  type?: string,
  payment_status?: string,
  transactions_count?: number,
  paid_before_expiry?: boolean,
  expired?: boolean,
  sort_direction: 'DESCENDING' | 'ASCENDING' = 'DESCENDING'
): Promise<InvoiceList> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.get(
      `/v0/invoices/list${buildURL(
        offset && 'offset',
        limit && 'limit',
        max_satoshi && 'max_satoshi',
        min_satoshi && 'min_satoshi',
        start_time && 'start_time',
        end_time && 'end_time',
        type && 'type',
        payment_status && 'payment_status',
        transactions_count && 'transactions_count',
        paid_before_expiry && 'paid_before_expiry',
        expired && 'expired',
        sort_direction && 'sort_direction'
      )}`
    )
    return response.data as InvoiceList
  } catch (error) {
    throw Error(error)
  }
}

export const Invoices_CreateOnchain = async (req: CreateInvoiceRequest): Promise<Invoice> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.post('/v0/invoices/onchain', req)
    return response.data as Invoice
  } catch (error) {
    throw Error(error)
  }
}

export const System_Ping = async (): Promise<{}> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.get(`/v0/system/ping`)
    return response.data as {}
  } catch (error) {
    throw Error(error)
  }
}

export const Transactions_GetTransaction = async (id?: string, client_id?: string): Promise<Transaction> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.get(`/v0/transactions${buildURL(id && 'id', client_id && 'client_id')}`)
    return response.data as Transaction
  } catch (error) {
    throw Error(error)
  }
}

export const Transactions_GetLightning = async (
  id?: string,
  payment_request?: string
): Promise<LightningTransaction> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.get(
      `/v0/transactions/lightning${buildURL(id && 'id', payment_request && 'payment_request')}`
    )
    return response.data as LightningTransaction
  } catch (error) {
    throw Error(error)
  }
}

export const Transactions_DecodeLightning = async (payment_request?: string): Promise<DecodeLightningResponse> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.get(`/v0/transactions/lightning/decode${buildURL(payment_request && 'payment_request')}`)
    return response.data as DecodeLightningResponse
  } catch (error) {
    throw Error(error)
  }
}

export const Transactions_SendLightning = async (req: SendLightningRequest): Promise<SendTransactionResponse> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.post('/v0/transactions/lightning/send', req)
    return response.data as SendTransactionResponse
  } catch (error) {
    throw Error(error)
  }
}

export const Transactions_ListTransactions = async (
  offset?: number,
  limit?: number,
  max_satoshi?: string,
  min_satoshi?: string,
  start_time?: string,
  end_time?: string,
  direction?: string,
  sort: 'DESCENDING' | 'ASCENDING' = 'DESCENDING',
  network_type?: string,
  status?: string,
  include_settlements?: boolean
): Promise<ListTransactionsResponse> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.get(
      `/v0/transactions/list${buildURL(
        offset && 'offset',
        limit && 'limit',
        max_satoshi && 'max_satoshi',
        min_satoshi && 'min_satoshi',
        start_time && 'start_time',
        end_time && 'end_time',
        direction && 'direction',
        sort && 'sort',
        network_type && 'network_type',
        status && 'status',
        include_settlements && 'include_settlements'
      )}`
    )
    return response.data as ListTransactionsResponse
  } catch (error) {
    throw Error(error)
  }
}

export const Transactions_GetOnchain = async (id?: string, client_id?: string): Promise<OnchainTransaction> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.get(`/v0/transactions/onchain${buildURL(id && 'id', client_id && 'client_id')}`)
    return response.data as OnchainTransaction
  } catch (error) {
    throw Error(error)
  }
}

export const Transactions_SendOnchain = async (req: SendOnchainRequest): Promise<OnchainTransaction> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.post('/v0/transactions/onchain/send', req)
    return response.data as OnchainTransaction
  } catch (error) {
    throw Error(error)
  }
}

export const Transactions_SendTransaction = async (req: SendTransactionRequest): Promise<SendTransactionResponse> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.post('/v0/transactions/send', req)
    return response.data as SendTransactionResponse
  } catch (error) {
    throw Error(error)
  }
}

export const Users_CreateUser = async (req: CreateUserRequest): Promise<User> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.post('/v0/users', req)
    return response.data as User
  } catch (error) {
    throw Error(error)
  }
}

export const Users_UpdateUser = async (req: UpdateUserRequest): Promise<{}> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.put('/v0/users', req)
    return response.data as {}
  } catch (error) {
    throw Error(error)
  }
}
