/* eslint-disable */

/* Generated by restful-react */

import { AxiosInstance } from 'axios'

let api: AxiosInstance

export const setCredentials = (axiosAPI: AxiosInstance, apiURL: string, apiKey?: string, timeout?: number): void => {
  api = axiosAPI

  api.defaults.baseURL = apiURL

  if (timeout) {
    api.defaults.timeout = timeout
  }

  if (apiKey) {
    api.defaults.headers = { Authorization: apiKey }
  }
}

const buildURL = (route: string, ...args: [string, any][]): string => {
  let url = route
  let params = ''
  args.forEach(arg => {
    const name = arg[0]
    const value = arg[1]
    if (value) {
      if (params === '') {
        params += `?${name}=${value}`
      } else {
        params += `&${name}=${value}`
      }
    }
  })
  return `${url}${params}`
}
export interface Account {
  /**
   * (if not zero) How much wiggle room to give the invoice status.
   * e.g: If the accepted spread is 2% (0.02), the invoice status is paid if the
   * amount paid was within 2% of the invoice amount. Can be fractions of a
   * percent, e.g: 1.5% (0.015) or 0.1% (0.001). This should be set if you are
   * annoyed by constant underpaid or overpaid invoices.
   */
  accepted_invoice_spread?: number
  address_type?: AddressType
  auto_exchange_currency?: FiatcurrencyFiatCurrency
  balance_bitcoin?: number
  balance_satoshi?: string
  /**
   * How many blocks new outbound on-chain transactions should be confirmed
   * within. A value of 1 will confirm transactions the fastest, but is also the
   * most expensive. Will not be higher than 1008.
   */
  default_conf_target?: number
  id?: string
  name?: string
  /**
   * How many blockchain confirmations an on-chain transaction needs before it
   * counts toward the payment status of an invoice.
   */
  onchain_invoice_confirmation_threshold?: number
  pending_balance_bitcoin?: number
}

/**
 * Information describing a user and its relation to an account.
 */
export interface AccountUser {
  /**
   * How much wiggle room is given between the wanted invoice amount
   * and actual paid invoice amount.
   */
  accepted_invoice_spread: number
  account_id: string
  account_name: string
  address_type: AddressType
  admin: boolean
  auto_exchange_currency?: FiatcurrencyFiatCurrency
  balance_bitcoin: number
  balance_satoshi: string
  create_time: string
  /**
   * How many blocks new outbound on-chain transactions should be confirmed
   * within. A value of 1 will confirm transactions the fastest, but is also the
   * most expensive. Will not be higher than 1008.
   */
  default_conf_target: number
  email: string
  first_name: string
  has_changed_password: boolean
  has_confirmed_2fa: boolean
  last_login_time: string
  last_name: string
  /**
   * How many onchain confirmations this account expects to consider an inbound
   * transaction confirmed.
   */
  onchain_invoice_confirmation_threshold: number
  owner: boolean
  pending_balance_bitcoin: number
  permissions: Permissions
  update_time: string
  user_id: string
  user_preferred_display_currency: CryptoCurrencyFormat
}

export interface AccountingTransaction {
  complete_time?: string
  direction?: TransactionDirection
  id?: string
  inbound_milli_sat?: string
  invoice_description?: string
  invoice_id?: string
  memo?: string
  network_fee_milli_sat?: string
  network_type?: NetworkType
  outbound_milli_sat?: string
  transaction_description?: string
}

/**
 * AddressType contains onchain address types that teslacoil supports receiving
 * to.
 *
 *  - CURRENT: Not all wallets support this address format, but you save on
 * fees by using it. Formally known as bech32
 *  - LEGACY: All wallets support this, but transcations are more
 * expensive. Formally known as P2WSH
 */
export type AddressType = 'CURRENT' | 'LEGACY'

/**
 * Response from the amount transacted endpoint.
 */
export interface AmountTransactedResponse {
  amount_transacted_bitcoin: number
  amount_transacted_fiat: number
}

export interface ApiKey {
  account_id: string
  create_time: string
  /**
   * The description (if any) associated with this key.
   */
  description: string
  expiry_time?: string
  /**
   * The hashed API key. API keys are not stored in cleartext in the database,
   * but compared against a hash. The user is only shown their API key once, and
   * Teslacoil is unable to retrieve it in cleartext again.
   */
  hashed_key: string
  /**
   * The last letters of the API key. This is stored so it is easier to
   * identify a specific key in a list of all keys.
   */
  last_letters: string
  last_use_time?: string
  permissions: Permissions
  whitelisted_ips: string[]
}

export interface BitcoinPrice {
  /**
   * The price of 1 BTC, expressed in USD.
   */
  price?: string
  /**
   * The timestamp for this price price provided.
   */
  price_timestamp?: string
}

export interface BlockchainTransaction {
  confirmations?: number
  confirmed_block_hash?: string
  confirmed_time?: string
  fee_bitcoin?: number
  fee_satoshi?: string
  inputs?: Input[]
  outputs?: Output[]
  reasonable_fee?: boolean
  replace_by_fee?: boolean
  sent_time?: string
}

/**
 * Description of event that triggered callback
 */
export type CallbackEvent = string

/**
 * Identifier for callback types
 */
export type CallbackIdentifier =
  | 'lightning-invoice'
  | 'onchain-invoice'
  | 'onchain-transaction'
  | 'lightning-transaction'

export interface ChangePasswordRequest {
  /**
   * The new user password. This is a required field.
   */
  new_password: string
  /**
   * The old user password. This is a required field.
   */
  old_password: string
  /**
   * The new user password, again. This field should be populated with the text
   * from a different field than the first new password. This is a required
   * field.
   */
  repeated_new_password: string
}

export interface Confirm2faRequest {
  /**
   * A 2FA code the user generated with their authenticator app. This is a
   * required field.
   */
  code: string
}

export interface Create2faResponse {
  /**
   * A 2FA secret the user can input into their authenticator app to
   * generate 2FA codes.
   */
  totp_secret: string
}

export interface CreateAccountRequest {
  name: string
}

export interface CreateApiKeyRequest {
  /**
   * An optional description of your API key. We highly recommend including
   * this, as it makes it much easier to identify a specific key later on.
   */
  description?: string
  expiry_time?: string
  permissions?: Permissions
  whitelisted_ips?: string[]
}

export interface CreateApiKeyResponse {
  key: string
  key_information: ApiKey
}

/**
 * The available fields for creating an invoice.
 */
export interface CreateInvoiceRequest {
  /**
   * The "wiggle room" for the amount an invoice expects to receive, to be
   * considered correcly paid. If this is not set, it defaults to the
   * corresponding value for the account.
   */
  accepted_spread?: number
  /**
   * The amount you want your created invoice to be for, measured in the
   * currency you specify.
   * This is a required field, and cannot be less than zero.
   */
  amount?: number
  /**
   * An (optional) callback URL to associate with this invoice. When the
   * invoice receives payment, we send a POST request to this URL to notify
   * you.
   */
  callback_url?: string
  /**
   * An (optional) ID you can associate with this invoice. This is never
   * used by Teslacoil, other than to identify your invoice when notifying
   * you of updates, as well as letting you retrieve the invoice by this ID.
   * We wont validate that this ID is unique to your invoice. So if you
   * want to use this field to later retrieve an invoice, you will have to
   * make sure yourself that it only identifies a single element.
   */
  client_id?: string
  currency?: CurrencyCurrency
  customer_company?: string
  customer_email?: string
  /**
   * An (optional) description to associate with this invoice. This is only
   * visible to the creator of the invoice.
   */
  description?: string
  exchange_currency?: FiatcurrencyFiatCurrency
  /**
   * The expiry of this invoice. Defaults to 1 hour, if not
   * set or set to zero. It is still possible for the user to send money to the
   * address associated with this invoice, but it will not make it count as
   * settled.
   */
  expiry_seconds?: number
  /**
   * An optional description to encode into the Lightning request
   * associated with this invoice. This is publicly visible. If creating an
   * on-chain invoice, setting this field has no effect.
   */
  lightning_memo?: string
  /**
   * How many blockchain confirmations an on-chain transaction needs before it
   * counts toward the payment status of this invoice. If this is not set, it
   * defaults the corresponding value for the account.
   */
  onchain_confirmation_threshold?: number
}

/**
 * Possible parameters when creating a trade.
 */
export interface CreateTradeRequest {
  amount?: number
  quote?: FiatcurrencyFiatCurrency
  side?: OrderSide
}

export interface CreateUserRequest {
  /**
   * The email of the user you want to create. This is a required field. After
   * the user is created, we'll send a message to this email address. The user
   * will then have to verify their address by clicking on a link in said email.
   * Until this is done, the user cannot sign in or otherwise use Teslacoil.
   * Until the user has activated 2FA and changed their password, it only has
   * very limited access to teslacoil.
   */
  email?: string
  first_name?: string
  last_name?: string
}

export interface CreatedInvoiceEvent {
  /**
   * The amount of this invoice, denominated in the currency.
   */
  amount: number
  currency: CurrencyCurrency
}

export interface CreatedTradeEvent {
  amount_bitcoin: number
  /**
   * The fiat amount traded, denominated in the currency.
   */
  amount_fiat: number
  currency: FiatcurrencyFiatCurrency
  side: OrderSide
  /**
   * What (if any) transaction this trade relates to.
   */
  transaction_id?: string
}

/**
 * - BITCOIN: Whole units of bitcoin
 *  - SATOSHIS: 1/100 000 000 of a bitcoin
 */
export type CryptoCurrencyFormat = 'BITCOIN' | 'SATOSHIS'

export interface CurrenciesConvertResponse {
  /**
   * amount is the quote amount per base amount.
   */
  amount: number
  base_currency: CurrencyCurrency
  quote_currency: CurrencyCurrency
}

export interface CurrenciesQuoteResponse {
  amount_btc: number
  amount_satoshi: number
  base_currency: CurrencyCurrency
  quote_currency: CurrencyCurrency
  rate: number
}

export interface DecodeLightningResponse {
  amount_satoshi?: string
  destination?: string
  expire_time?: string
  fallback_onchain_address?: string
  memo?: string
  /**
   * The hash of the preimage.
   */
  payment_hash?: string
}

/**
 *  - LOCAL_CHANNEL_OPEN: A channel opening transaction for a channel opened by our node.
 *  - REMOTE_CHANNEL_OPEN: A channel opening transaction for a channel opened by a remote node.
 *  - CHANNEL_OPEN_FEE: The on chain fee paid to open a channel.
 *  - CHANNEL_CLOSE: A channel closing transaction.
 *  - RECEIPT: Receipt of funds. On chain this reflects receives, off chain settlement
 * of invoices.
 *  - PAYMENT: Payment of funds. On chain this reflects sends, off chain settlement
 * of our payments.
 *  - FEE: Payment of fees.
 *  - CIRCULAR_RECEIPT: Receipt of a payment to ourselves.
 *  - FORWARD: A forward through our node.
 *  - FORWARD_FEE: Fees earned from forwarding.
 *  - CIRCULAR_PAYMENT: Sending of a payment to ourselves.
 *  - CIRCULAR_FEE: The fees paid to send an off chain payment to ourselves.
 *  - SWEEP: A transaction that sweeps funds back into our wallet's control.
 *  - SWEEP_FEE: The amount of fees paid for a sweep transaction.
 *  - CHANNEL_CLOSE_FEE: The fees paid to close a channel.
 */
export type EntryType =
  | 'UNKNOWN'
  | 'LOCAL_CHANNEL_OPEN'
  | 'REMOTE_CHANNEL_OPEN'
  | 'CHANNEL_OPEN_FEE'
  | 'CHANNEL_CLOSE'
  | 'RECEIPT'
  | 'PAYMENT'
  | 'FEE'
  | 'CIRCULAR_RECEIPT'
  | 'FORWARD'
  | 'FORWARD_FEE'
  | 'CIRCULAR_PAYMENT'
  | 'CIRCULAR_FEE'
  | 'SWEEP'
  | 'SWEEP_FEE'
  | 'CHANNEL_CLOSE_FEE'

export interface EstimateBlockchainFeesResponse {
  average_fee: number
  currency: CurrencyCurrency
  sats_per_byte: number
}

export interface EstimateLightningFeesResponse {
  currency: CurrencyCurrency
  fee: number
}

/**
 * Contains the information you get about each activity. It will always have
 * exactly one event.
 */
export interface Event {
  created_invoice?: CreatedInvoiceEvent
  created_trade?: CreatedTradeEvent
  description?: string
  event_id: string
  incoming_transaction?: IncomingTransactionEvent
  invoice_status_change?: InvoiceStatusChangeEvent
  sent_lightning_transaction?: SentLightningTransactionEvent
  sent_onchain_transaction?: SentOnchainTransactionEvent
  time: string
}

export interface GetJwtRequest {
  /**
   * The ID or name of the account that the JWT will be valid for. If not set,
   * the JWT is only valid for certain user-related endpoints.
   */
  account_identifier?: string
  /**
   * The email of the user that's requesting a JWT. This is a required field.
   */
  email: string
  /**
   * The password of the user that's requesting a JWT. This is a required field.
   */
  password: string
  /**
   * The 2FA code to use when requesting a JWT. If 2FA is enabled, this is a
   * required field.
   */
  totp_code?: string
}

export interface GetJwtResponse {
  /**
   * The created JWT. This can be used to authenticate against the API, by
   * prefixing it with "Bearer " and placing in the authorization header.
   */
  token: string
}

export interface GiveAccessRequest {
  permissions?: Permissions
  user_id?: string
}

export interface IncomingTransactionEvent {
  amount_bitcoin: number
}

export interface Input {
  /**
   * The address of this input. Usually contains one address, but can be
   * multiple if the utxo used multisig.
   */
  addresses?: string[]
  amount_bitcoin?: number
  parent_network_id?: string
  /**
   * The output index of the underlying Bitcoin transaction that this specfic
   * transfer of funds refer to.
   */
  transaction_output?: number
}

/**
 * An invoice that contains all the fields that a Lightning and an on-chain
 * invoice has in common. It also contains a type parameter which indicates
 * whether it is a Lightning invoice or an on-chain invoice.
 */
export interface Invoice {
  /**
   * The account that created this invoice.
   */
  account_id: string
  /**
   * How much this invoice has received in payments, so far. This is measured in
   * whole lots of the currency associated with this invoice.
   */
  amount_paid: number
  /**
   * How much this invoice has received in payments, denominated in satoshis.
   */
  amount_paid_satoshi: string
  /**
   * The bitcoin address (if any) associated with this invoice.
   */
  bitcoin_address: string
  /**
   * The callback URL associated with this invoice, if any.
   */
  callback_url: string
  /**
   * URL to Teslacoil checkout page. Users can be sent here, to pay the amount
   * requested in the invoice.
   */
  checkout_url: string
  /**
   * An (optional) ID you associated with this invoice. This is never
   * used by Teslacoil, other than to identify your invoice when notifying
   * you of updates, as well as letting you retrieve the transaction by this
   * ID. We wont validate that this ID is unique to your invoices. So if you
   * want to use this field to later retrieve a invoice, you will have to
   * make sure yourself that it only identifies a single element.
   */
  client_id: string
  /**
   * When this invoice was created.
   */
  create_time: string
  currency: CurrencyCurrency
  /**
   * The company of the customer that is expect to pay this invoice.
   */
  customer_company: string
  /**
   * The email of the customer that is expect to pay this invoice.
   */
  customer_email: string
  /**
   * The description associated with this invoice, if any.
   */
  description: string
  exchange_currency?: FiatcurrencyFiatCurrency
  /**
   * Whether or not this invoice is expired. If this invoice has an associated
   * Lightning request, it is not to possible to pay it after the invoice is
   * expired. If it has a bitcoin address associated with it, it is still
   * possible to send money to the associated bitcoin address after the invoices
   * is expired, but it will not cause the invoice to become settled.
   */
  expired: boolean
  /**
   * How long this invoice is valid for, measured in seconds. If this invoice
   * has an associated Lightning request, it is not to possible to pay
   * it after the invoice is expired. If it has a bitcoin address associated
   * with it, it is
   *  still possible to send money to the associated bitcoin address after the
   *  invoices is expired, but it will not cause the invoice to become settled.
   */
  expiry_seconds: number
  /**
   * Whether or not this invoice has received any transactions which are
   * yet-to-be accepted. This is based on the on-chain confirmation threshold
   * value for this invoice.
   */
  has_pending_transactions: boolean
  /**
   * The Teslacoil ID for this invoice.
   */
  id: string
  lightning_request?: string
  /**
   * How many blockchain confirmations an on-chain transaction needs before it
   * counts toward the payment status of this invoice.
   */
  onchain_confirmation_threshold: number
  /**
   * Whether this invoice received sufficient payment before it expired or not.
   */
  paid_before_expiry: boolean
  payment_status: InvoiceStatus
  /**
   * The amount of money requested in this invoice. It is measured in whole lots
   * of the currency field. If the currency is set to BTC, this field is going
   * to equal the field for how much BTC was requested.
   */
  requested_amount: number
  /**
   * The requested amount of money, measured in bitcoin. This is calculated when
   * fetching the invoice, based on current exchange rates. If the invoice
   * has been partially paid, this field is updated to reflect how much more
   * bitcoin we are expecting to receive.
   */
  requested_amount_bitcoin: number
  /**
   * The requested amount of money, measured in satoshis. This is calculated
   * when fetching the invoice, based on current exchange rates. If the invoice
   * has been partially paid, this field is updated to reflect how much more
   * bitcoin we are expecting to receive.
   */
  requested_amount_satoshi: string
  /**
   * When this invoice was settled, if at all.
   */
  settle_time?: string
  /**
   * IDs of transactions paying to this invoice. This includes any transactions
   * that are yet-to-be accepted, based on the on-chain confirmation threshold
   * value for this invoice.
   */
  transaction_ids: string[]
  /**
   * Transactions paying to this invoice. This includes any transactions that
   * are yet-to-be accepted, based on the on-chain confirmation threshold value
   * for this invoice.
   */
  transactions: Transaction[]
}

export interface InvoiceList {
  invoices: Invoice[]
  total: number
}

/**
 * - UNPAID: The invoice has not received a payment
 *  - PAID: This invoice has received a payment for the exact amount we expected
 *  - OVERPAID: Money was sent, but more than we expected. The invoice can be considered
 * settled
 *  - UNDERPAID: Money was sent, but less than we expected. The invoice is not considered
 * settled.
 */
export type InvoiceStatus = 'UNPAID' | 'PAID' | 'OVERPAID' | 'UNDERPAID'

export interface InvoiceStatusChangeEvent {
  /**
   * the amount of the invoice, denominated in the currency.
   */
  amount_fiat: number
  /**
   * How much this invoice has received in payments, so far. This is measured in
   * whole lots of the currency associated with this invoice.
   */
  amount_paid: number
  currency: CurrencyCurrency
  invoice_id: string
  invoice_status: InvoiceStatus
}

export interface LightningTransaction {
  amount_bitcoin: number
  amount_satoshi: string
  /**
   * The URL to hit when the status of this transaction changes.
   */
  callback_url: string
  /**
   * Every transaction can have a client ID associated to it. This is not used
   * by Teslacoil, but can be used to correlate transactions with your internal
   * database when handling callbacks and other interactions with the Teslacoil
   * API.
   */
  client_id: string
  /**
   * The creation time of this transaction.
   */
  create_time: string
  /**
   * An internal description associated with this transaction. This is only
   * visible to the creator of the transaction.
   */
  description: string
  direction: TransactionDirection
  /**
   * The hashed preimage of this transaction.
   */
  hashed_preimage: string
  id: string
  invoice_id?: string
  /**
   * The lightning request belonging to this transactions. All Lightning
   * transactions have a lightning request associated with them. Lightning
   * requests specify the recipient and amount of a transaction, as well as
   * other, optional, information.
   */
  lightning_request: string
  /**
   * The encoded lightning request description of this transaction. This is
   * encoded into the lightning request, and is publicly visible.
   */
  memo: string
  network_fee_bitcoin: number
  network_fee_satoshi: string
  /**
   * If the lightning payment failed, this field specifies why this happened.
   */
  payment_error: string
  /**
   * The preimage of this transaction, if any. Preimages for transactions are
   * only available if they are settled.
   */
  preimage: string
  /**
   * The settlement time of this transaction. This is only available for
   * completed transactions.
   */
  settlement_time: string
  status: TransactionStatus
  trades: Trade[]
}

export interface ListAccountNamesResponse {
  names: string[]
}

export interface ListAccountsResponse {
  accounts: Account[]
}

export interface ListApiKeysResponse {
  keys: ApiKey[]
}

export interface ListSettlementsResponse {
  settlements: Settlement[]
  total: number
}

export interface ListTradesResponse {
  total: number
  trades: Trade[]
}

export interface ListTransactionsResponse {
  /**
   * How many transactions matched the filtering options sent. Can be used to
   * implement pagination client-side.
   */
  total: number
  transactions: Transaction[]
}

export type LogLevel = 'TRACE' | 'DEBUG' | 'INFO' | 'WARN' | 'ERROR' | 'OFF'

export interface LogLevels {
  levels?: {
    [key: string]: LogLevel
  }
}

/**
 * - ONCHAIN: A transaction made on the Bitcoin blockchain
 *  - LIGHTNING: A transaction sent on the Lightning Network
 */
export type NetworkType = 'ONCHAIN' | 'LIGHTNING'

export interface NodeAuditResponse {
  /**
   * On chain reports for the period queried.
   */
  reports?: ReportEntry[]
}

export interface OnchainTransaction {
  /**
   * The address this transaction was sent to. If this is an outgoing
   * transaction, this is the recipient. If this as incoming, it is our deposit
   * address.
   */
  address: string
  /**
   * How much this transaction was for, i.e. how much it credited/debited the
   * account. Measured in bitcoin.
   */
  amount_bitcoin: number
  /**
   * How much this transaction was for, i.e. how much it credited/debited the
   * account. Measured in satoshis.
   */
  amount_satoshi: string
  /**
   * The URL, if any, to send updates to whenever events related to this
   * transaction occurs.
   */
  callback_url: string
  /**
   * Every transaction can have a client ID associated to it. This is not used
   * by Teslacoil, but can be used to correlate transactions with your internal
   * database when handling callbacks and other interactions with the Teslacoil
   * API.
   */
  client_id: string
  /**
   * If this transaction is confirmed, this is the block height that the
   * transaction was confirmed at.
   */
  confirmation_block_height: string
  /**
   * If this transaction is confirmed, this is the time that the transaction was
   * confirmed.
   */
  confirmation_time: string
  /**
   * Whether or not this transaction has been confirmed by being placed into the
   * Bitcoin blockchain. This does not happen immediately after a transaction is
   * made, because a Bitcoin miner needs to process it first.
   */
  confirmed: boolean
  /**
   * When this transaction was created.
   */
  create_time: string
  description: string
  direction: TransactionDirection
  /**
   * The internal Teslacoil ID of this transaction. Can be used to retrieve the
   * transaction at a later point in time.
   */
  id: string
  invoice_id?: string
  /**
   * How much fees we paid to the bitcoin miners for this transaction. Not set
   * if this transaction was sent to us, as we can't know that.
   */
  network_fee_bitcoin: number
  /**
   * How much fees we paid to the bitcoin miners for this transaction. Not set
   * if this transaction was sent to us, as we can't know that.
   */
  network_fee_satoshi: string
  /**
   * The Bitcoin network transaction ID of this transaction. This can be used to
   * look up the transaction in a block explorer or a Bitcoin node.
   */
  network_id: string
  trades: Trade[]
  /**
   * The output index of the underlying Bitcoin transaction that this specfic
   * transfer of funds refer to.
   */
  transaction_output: string
}

/**
 * The valid sides for a trade. Used in getting a RFQ (request for quote), and
 * creating and describing trades.
 *
 *  - BUY: Buy bitcoin
 *  - SELL: Sell bitcoin
 */
export type OrderSide = 'BUY' | 'SELL'

export interface Output {
  /**
   * The address of this output. Usually contains one address, but can be
   * multiple if the utxo used multisig.
   */
  addresses?: string[]
  amount_bitcoin?: number
  /**
   * The output index of the underlying Bitcoin transaction that this specfic
   * transfer of funds refer to.
   */
  transaction_output?: number
}

export interface Permissions {
  accounting: Privileges
  accounts: Privileges
  api_keys: Privileges
  auth: Privileges
  currencies: Privileges
  exchange: Privileges
  experimental: Privileges
  invoices: Privileges
  system: Privileges
  transactions: Privileges
  users: Privileges
}

export interface Privileges {
  create: boolean
  delete: boolean
  read: boolean
  update: boolean
}

export interface RecentEventsResponse {
  events?: Event[]
}

export interface ReportEntry {
  /**
   * The amount of the entry, expressed in millisatoshis.
   */
  amount?: string
  /**
   * The asset affected by the entry.
   */
  asset?: string
  btc_price?: BitcoinPrice
  /**
   * Whether the entry is a credit or a debit.
   */
  credit?: boolean
  /**
   * The fiat amount of the entry's amount in USD.
   */
  fiat?: string
  /**
   * An additional note for the entry, providing additional context.
   */
  note?: string
  /**
   * Whether the entry occurred on chain or off chain.
   */
  on_chain?: boolean
  /**
   * A unique identifier for the entry, if available.
   */
  reference?: string
  /**
   * The unix timestamp of the event.
   */
  timestamp?: string
  /**
   * The transaction id of the entry.
   */
  txid?: string
  type?: EntryType
}

export interface ResetPasswordRequest {
  /**
   * The users password. This is a required field.
   */
  password?: string
  /**
   * The users password resset token, obtained through requesting one being sent
   * to the users email. This is a required field.
   */
  token?: string
}

export interface RestError {
  error?: RestErrorContent
}

export interface RestErrorContent {
  details?: { [key: string]: any }[]
  docs?: string
  message?: string
  status?: string
}

export interface RiskLimitsResponse {
  [key: string]: any
}

export interface SendLightningRequest {
  /**
   * The URL we send a POST request to when the transaction is completed.
   */
  callback_url?: string
  /**
   * An (optional) ID you associated with this transaction. This is never
   * used by Teslacoil, other than to identify your transaction when notifying
   * you of updates, as well as letting you retrieve the transaction by this
   * ID. We wont validate that this ID is unique to your transaction. So if you
   * want to use this field to later retrieve a transaction, you will have to
   * make sure yourself that it only identifies a single element.
   */
  client_id?: string
  /**
   * An optional description to associate with this transaction. This is only
   * visible to the sender of this request.
   */
  description?: string
  exchange_currency?: FiatcurrencyFiatCurrency
  lightning_request?: string
}

export interface SendOnchainRequest {
  /**
   * The destination bitcoin address. Must be set.
   */
  address?: string
  /**
   * The amount to send, denominated in the currency supplied.
   * Cannot be zero or negative.
   */
  amount?: number
  /**
   * The URL, if any, to send updates to whenever events related to this
   * transaction occurs.
   */
  callback_url?: string
  /**
   * An (optional) ID you can associate with this transaction. This is never
   * used by Teslacoil, other than to identify your transaction when notifying
   * you of updates, as well as letting you retrieve the transaction by this ID.
   * We wont validate that this ID is unique to your transactions. So if you
   * want to use this field to later retrieve a transaction, you will have to
   * make sure yourself that it only identifies a single element.
   */
  client_id?: string
  currency?: CurrencyCurrency
  /**
   * An (optional) description to associate with this transaction. Only visible
   * to the sender of the transaction.
   */
  description?: string
  exchange_currency?: FiatcurrencyFiatCurrency
  /**
   * If set, we use this as the fee rate for your transaction, measured in
   * satoshi per (virtual) byte.
   */
  fee_satoshi_per_byte?: number
  /**
   * If set, we try and construct the transaction such that it is confirmed by
   * this number of blocks. A higher value here means a lower network fee, but
   * you will have to wait longer until the transaction is included in the
   * blockchain. A lower value would make your transaction confirm quicker, but
   * it would be more expensive.
   */
  target_confirmation?: number
}

export interface SendPasswordResetEmailRequest {
  /**
   * The email the user signed up with. This is a required field.
   */
  email?: string
}

/**
 * The fields returned when a transaction was successfully initiated.
 * It does not include specific information about the transaction for security
 * purposes, as there are several steps payment must go through before it is
 * sent which might take some time. You can poll for the latest updates using
 * the provided url.
 */
export interface SendTransactionResponse {
  id?: string
  url?: string
}

export interface SentLightningTransactionEvent {
  amount_bitcoin: number
}

export interface SentOnchainTransactionEvent {
  amount_bitcoin: number
}

export interface SetLogLevelsRequest {
  level?: LogLevel
  levels?: SetLogLevelsRequestDetailed
}

export interface SetLogLevelsRequestDetailed {
  levels?: {
    [key: string]: LogLevel
  }
}

/**
 * A settlement represents the finalization of trades performed at a prior time.
 * The parties transfer funds to each other to settle their debts.
 */
export interface Settlement {
  amount?: number
  create_time?: string
  currency?: CurrencyCurrency
  direction?: TransactionDirection
  /**
   * Whether or not this settlement is considered finished. It is considered
   * finished if all parties have sent and received the sums agreed upon.
   */
  done?: boolean
  /**
   * When, if any, this settlement was finalized.
   */
  finalize_time?: string
  id?: string
  transactions?: Transaction[]
}

/**
 * - DESCENDING: Sort transactions descending, chronologically
 *  - ASCENDING: Sort transactions ascending, chronologically
 */
export type SortingDirection = 'DESCENDING' | 'ASCENDING'

export interface Statement {
  account_id?: string
  closing_balance_milli_sat?: string
  end_time?: string
  inbound_milli_sat?: string
  network_fee_milli_sat?: string
  opening_balance_milli_sat?: string
  outbound_milli_sat?: string
  start_time?: string
  transactions?: AccountingTransaction[]
}

export interface TeslaPayDeposit {
  /**
   * The invoice amount, denominated in the currency returned.
   */
  amount: number
  /**
   * How much this invoice has received in payments, so far. This is measured in
   * whole lots of the currency associated with this invoice.
   */
  amount_paid: number
  /**
   * The bitcoin address associated with this invoice.
   */
  bitcoin_address: string
  currency: CurrencyCurrency
  /**
   * the custom order ID associated with this invoice.
   */
  custom_order_id?: string
  /**
   * The company of the customer that is expect to pay this invoice.
   */
  customer_company?: string
  /**
   * An (optional) description that was associated with this invoice.
   */
  description: string
  /**
   * What time this invoice is expired and can no longer be paid.
   */
  expire_time: string
  expired: boolean
  has_pending_transactions: boolean
  /**
   * The lightning request associated with this invoice.
   */
  lightning_request?: string
  /**
   * Your company name.
   */
  recipient: string
  /**
   * The bitcoin amount expected to be received given the current exchange rate.
   * If the invoice has already received partial payment, this field contains
   * the amount of bitcoin we expect to reach the requested amount.
   */
  remaining_amount_bitcoin: number
  /**
   * When this invoice was settled, if at all.
   */
  settle_time?: string
  status: InvoiceStatus
}

/**
 * Contains the fields necessary for a third party to fullfill a withdrawal from
 * Teslacoil.
 */
export interface TeslaPayWithdrawal {
  /**
   * The amount the user is withdrawing, denominated in the given currency.
   */
  amount: number
  /**
   * The amount the user is withdrawing, denominated in bitcoin.
   */
  amount_bitcoin: number
  /**
   * When this withdrawal was initiated, if any.
   */
  create_time: string
  currency: CurrencyCurrency
  /**
   * When this withdrawal was executed, if any.
   */
  execute_time?: string
  expire_time: string
  /**
   * How long this withdrawal is valid before it expires, measured in seconds.
   */
  expiry_seconds: number
  /**
   * Bech32-encoded lightning:... URL the user scan scan/input to withdraw using
   * LNURL.
   */
  ln_url: string
}

export interface Trade {
  amount_base: number
  amount_quote: number
  base: CurrencyCurrency
  create_time: string
  id: string
  quote: CurrencyCurrency
  rate: number
  side: OrderSide
  status: TradeStatus
  /**
   * what (if any) transaction this trade relates to.
   */
  transaction_id?: string
}

/**
 * The valid sides for a trade. Used in getting a RFQ (request for quote), and
 * creating and describing trades.
 *
 *  - TRADE_FAILED: The trade could not be completed.
 *  - TRADE_ACCEPTED: The OTC desk has accepted the order.
 *  - TRADE_INITIATED: A trade has been initiated, but the OTC desk has not yet accepted the
 * order.
 */
export type TradeStatus = 'TRADE_FAILED' | 'TRADE_ACCEPTED' | 'TRADE_INITIATED'

export interface Transaction {
  account_id: string
  amount_bitcoin: number
  amount_satoshi: string
  /**
   * The URL, if any, to send updates to whenever events related to this
   * transaction occurs.
   */
  callback_url: string
  client_id: string
  complete_time?: string
  create_time: string
  description: string
  /**
   * Either the Bitcoin address or Lighting request of this transcation.
   */
  destination: string
  direction: TransactionDirection
  id: string
  invoice_id?: string
  network_fee_bitcoin: number
  network_fee_satoshi: string
  /**
   * The Bitcoin network transaction ID or the lightning transaction payment
   * hash of this transaction. It can be used to identify the transaction in the
   * respective networks.
   */
  network_id: string
  network_type: NetworkType
  status: TransactionStatus
  trades: Trade[]
}

/**
 * - INCOMING: Received to Teslacoil, a deposit
 *  - OUTGOING: Sent from Teslacoil, a withdrawal
 */
export type TransactionDirection = 'INCOMING' | 'OUTGOING'

/**
 * - PENDING: The transaction has not reached a conclusion whether it's completed or
 * failed yet
 *  - COMPLETED: The transaction has been received by the recipient, and is settled.
 *  - FAILED: The transaction has failed
 */
export type TransactionStatus = 'PENDING' | 'COMPLETED' | 'FAILED'

export interface UpdateAccessRequest {
  new_permissions?: Permissions
  user_id?: string
}

export interface UpdateAccountRequest {
  /**
   * If this field is set, the status of all paid invoices will be given a
   * little wiggle room. e.g: If the accepted spread is 2% (0.02), the invoice
   * status is paid if the amount paid was within 2% of the invoice amount. Can
   * be fractions of a percent, e.g: 1.5% (0.015) or 0.1% (0.001). This should
   * be set if you are annoyed by constant underpaid or overpaid invoices.
   */
  accepted_invoice_spread?: number
  address_type?: AddressType
  /**
   * The new value for outbound on-chain transaction confirmation target. Used
   * for fee estimation. If set, smallest value is 1, highest is 1008.
   */
  default_conf_target?: number
  new_auto_exchange_currency?: FiatcurrencyFiatCurrency
  new_name?: string
  new_permissions?: Permissions
  /**
   * The new value for the on-chain invoice confirmation threshold setting.
   */
  onchain_invoice_confirmation_threshold?: number
  /**
   * If this field is set, the accepted invoice spread will be removed from the
   * account.
   */
  remove_accepted_invoice_spread?: boolean
  /**
   * If this field is set, the auto exchange currency will be removed, and no
   * invoices will be auto exchanged going forward.
   */
  remove_auto_exchange_currency?: boolean
}

export interface UpdateUserRequest {
  first_name?: string
  last_name?: string
  preferred_display_currency?: CryptoCurrencyFormat
}

/**
 * Response from the usage endpoint.
 */
export interface UsageResponse {
  /**
   * How many invoices have been created.
   */
  invoice_count: number
  settlement_count: number
  /**
   * How many trades have been created.
   */
  trade_count: number
  /**
   * How many transactions have been created.
   */
  transaction_count: number
}

export interface User {
  email: string
  first_name: string
  id: string
  last_name: string
  preferred_crypto_display_currency: CryptoCurrencyFormat
}

/**
 * ISO 4217: alpha 3-letter e.g EUR, BTC.
 *
 *  - BTC: BTC is the ticker for bitcoin
 */
export type CurrencyCurrency = 'BTC' | 'GBP' | 'NOK' | 'USD' | 'EUR'

export type FiatcurrencyFiatCurrency = 'GBP' | 'NOK' | 'USD' | 'EUR'

/**
 * - CREATE_TIME: Sort invoices chronologically. This is the default sorting property.
 *  - STATUS: Sort invoices by their payment status.
 *  - AMOUNT: Sort invoices by the amount they are for.
 */
export type InvsortProperty = 'CREATE_TIME' | 'STATUS' | 'AMOUNT'

/**
 * Response when executing a LNURL withdrawal.
 */
export interface LnurlExecuteWithdrawalResponse {
  /**
   * The reason for this withdrawal failing, if any. Only set if the status is
   * error.
   */
  reason?: string
  status?: LnurlStatus
}

export interface LnurlGetWithdrawalResponse {
  /**
   * Link the client needs to hit, in order to execute the withdrawal.
   */
  callback?: string
  defaultDescription?: string
  /**
   * The secret associated with this withdrawal.
   */
  k1?: string
  /**
   * Maximum amount that can be withdrawn for this withdrawal, measured in
   * millisatoshis.
   */
  maxWithdrawable?: string
  /**
   * Minimum amount that can be withdrawn for this withdrawal, measured in
   * millisatoshis.
   */
  minWithdrawable?: string
  /**
   * If status is error, this explains what went wrong.
   */
  reason?: string
  status?: LnurlStatus
  tag?: LnurlTag
}

/**
 * Possible statuses when executing LNURL withdrawals.
 */
export type LnurlStatus = 'OK' | 'ERROR'

export type LnurlTag = 'WITHDRAW_REQUEST'

export interface PreptxExecuteRequest {
  id?: string
  /**
   * Either a bitcoin address or payment request, where the previously specified
   * amount will be sent.
   */
  payment_destination?: string
}

/**
 * A prepared transaction that could potentially result in a transaction at a
 * later point.
 */
export interface PreptxPreparation {
  /**
   * The amount to send, denominated in set currency.
   */
  amount: number
  /**
   * The callback URL associated with this prepared transaction, if any.
   */
  callback_url?: string
  /**
   * URL to the checkout page the end user can be sent to, in order to complete
   * their withdrawal.
   */
  checkout_url: string
  create_time: string
  currency: CurrencyCurrency
  execute_time?: string
  expire_time: string
  /**
   * How long this prepared is valid before it expires, measured in seconds.
   */
  expiry_seconds: number
  /**
   * The Teslacoil ID of this prepared transaction.
   */
  id: string
  k1_secret?: string
  /**
   * An encoded LNURL containing a link to GET more information about the
   * withdrawal, including the secret.
   */
  ln_url: string
  /**
   * The ID of the transaction that happened as a result of this prepared
   * transaction. Not set if the prepared transaction was never executed.
   */
  transaction_id?: string
}

export interface PreptxPrepareRequest {
  /**
   * The amount to send, denominated in the currency supplied.
   * Cannot be zero or negative.
   */
  amount?: number
  /**
   * A callback URL to associate with this prepared transaction. If this field
   * is provided, we send a callback to the specified URL when this transaction
   * is executed.
   */
  callback_url?: string
  currency?: CurrencyCurrency
  /**
   * If set, the users bitcoin wallet will hit this endpoint to complete the
   * withdrawal It is useful if you want to validate something internally in
   * your system before sending money to the user. If set, you must remember to
   * execute the prepared transaction.
   */
  custom_complete_url?: string
  /**
   * When a prepared transaction expires, it can no longer be executed.
   * It defaults to one hour. If set, must be greater than 10 seconds.
   */
  expiry_seconds?: number
}

/**
 * - CREATE_TIME: Sort transactions chronologically. This is the default sorting property.
 *  - STATUS: Sort invoices by their status.
 *  - AMOUNT: Sort invoices by their size.
 */
export type TxsortProperty = 'CREATE_TIME' | 'STATUS' | 'AMOUNT'

export interface AccountingNodeAuditQueryParams {
  /**
   * Only audit transactions after this time.
   */
  start_time?: string
  /**
   * The end date (closing date) for the account statement
   * Only audit transactions before this time.
   */
  end_time?: string
}

export const Accounting_NodeAudit = async (start_time?: string, end_time?: string): Promise<NodeAuditResponse> => {
  try {
    const response = await api.get(
      buildURL('/v0/accounting/audit/node', ['start_time', start_time], ['end_time', end_time])
    )
    return response.data as NodeAuditResponse
  } catch (error) {
    throw Error(error)
  }
}

export interface AccountingGetStatementQueryParams {
  /**
   * The start time (opening date) for the account statement.
   */
  start_time?: string
  /**
   * The end date (closing date) for the account statement.
   */
  end_time?: string
}

export const Accounting_GetStatement = async (start_time?: string, end_time?: string): Promise<Statement> => {
  try {
    const response = await api.get(
      buildURL('/v0/accounting/statement', ['start_time', start_time], ['end_time', end_time])
    )
    return response.data as Statement
  } catch (error) {
    throw Error(error)
  }
}

export const Accounts_Get = async (): Promise<Account> => {
  try {
    const response = await api.get(buildURL('/v0/accounts'))
    return response.data as Account
  } catch (error) {
    throw Error(error)
  }
}

export const Accounts_Create = async (req: CreateAccountRequest): Promise<Account> => {
  try {
    const response = await api.post('/v0/accounts', req)
    return response.data as Account
  } catch (error) {
    throw Error(error)
  }
}

export const Accounts_Update = async (req: UpdateAccountRequest): Promise<Account> => {
  try {
    const response = await api.put('/v0/accounts', req)
    return response.data as Account
  } catch (error) {
    throw Error(error)
  }
}

export interface AccountsRemoveAccessResponse {}

export interface AccountsRemoveAccessQueryParams {
  /**
   * ID of the user that should no longer have access.
   */
  user_id?: string
}

export const Accounts_RemoveAccess = async (user_id?: string): Promise<{}> => {
  try {
    const response = await api.delete(buildURL('/v0/accounts/access', ['user_id', user_id]))
    return response.data as {}
  } catch (error) {
    throw Error(error)
  }
}

export interface AccountsUpdateAccessResponse {}

export const Accounts_UpdateAccess = async (req: UpdateAccessRequest): Promise<{}> => {
  try {
    const response = await api.post('/v0/accounts/access', req)
    return response.data as {}
  } catch (error) {
    throw Error(error)
  }
}

export interface AccountsGiveAccessResponse {}

export const Accounts_GiveAccess = async (req: GiveAccessRequest): Promise<{}> => {
  try {
    const response = await api.put('/v0/accounts/access', req)
    return response.data as {}
  } catch (error) {
    throw Error(error)
  }
}

export const Accounts_List = async (): Promise<ListAccountsResponse> => {
  try {
    const response = await api.get(buildURL('/v0/accounts/list'))
    return response.data as ListAccountsResponse
  } catch (error) {
    throw Error(error)
  }
}

export const Accounts_ListAccountNames = async (): Promise<ListAccountNamesResponse> => {
  try {
    const response = await api.get(buildURL('/v0/accounts/names'))
    return response.data as ListAccountNamesResponse
  } catch (error) {
    throw Error(error)
  }
}

export interface AccountsGetUserInfoQueryParams {
  /**
   * If you are an account owner, you can set this field to get information
   * about other users.
   */
  user_id?: string
}

export const Accounts_GetUserInfo = async (user_id?: string): Promise<AccountUser> => {
  try {
    const response = await api.get(buildURL('/v0/accounts/user', ['user_id', user_id]))
    return response.data as AccountUser
  } catch (error) {
    throw Error(error)
  }
}

export interface ApiKeysDeleteQueryParams {
  /**
   * The key you want to delete.
   */
  hash?: string
}

export const ApiKeys_Delete = async (hash?: string): Promise<ApiKey> => {
  try {
    const response = await api.delete(buildURL('/v0/apikeys', ['hash', hash]))
    return response.data as ApiKey
  } catch (error) {
    throw Error(error)
  }
}

export interface ApiKeysGetQueryParams {
  /**
   * The hash of the API key you want to retrieve.
   */
  hash?: string
}

export const ApiKeys_Get = async (hash?: string): Promise<ApiKey> => {
  try {
    const response = await api.get(buildURL('/v0/apikeys', ['hash', hash]))
    return response.data as ApiKey
  } catch (error) {
    throw Error(error)
  }
}

export const ApiKeys_Create = async (req: CreateApiKeyRequest): Promise<CreateApiKeyResponse> => {
  try {
    const response = await api.post('/v0/apikeys', req)
    return response.data as CreateApiKeyResponse
  } catch (error) {
    throw Error(error)
  }
}

export const ApiKeys_List = async (): Promise<ListApiKeysResponse> => {
  try {
    const response = await api.get(buildURL('/v0/apikeys/list'))
    return response.data as ListApiKeysResponse
  } catch (error) {
    throw Error(error)
  }
}

export interface AuthenticationChangePasswordResponse {}

export const Authentication_ChangePassword = async (req: ChangePasswordRequest): Promise<{}> => {
  try {
    const response = await api.put('/v0/auth/change_password', req)
    return response.data as {}
  } catch (error) {
    throw Error(error)
  }
}

export interface AuthenticationConfirm2faResponse {}

export const Authentication_Confirm2fa = async (req: Confirm2faRequest): Promise<{}> => {
  try {
    const response = await api.put('/v0/auth/confirm_2fa', req)
    return response.data as {}
  } catch (error) {
    throw Error(error)
  }
}

export interface AuthenticationCreate2faRequestBody {}

export const Authentication_Create2fa = async (): Promise<Create2faResponse> => {
  try {
    const response = await api.post('/v0/auth/create_2fa')
    return response.data as Create2faResponse
  } catch (error) {
    throw Error(error)
  }
}

export const Authentication_GetJwt = async (req: GetJwtRequest): Promise<GetJwtResponse> => {
  try {
    const response = await api.post('/v0/auth/get_jwt', req)
    return response.data as GetJwtResponse
  } catch (error) {
    throw Error(error)
  }
}

export const Authentication_RefreshJwt = async (): Promise<GetJwtResponse> => {
  try {
    const response = await api.get(buildURL('/v0/auth/refresh_jwt'))
    return response.data as GetJwtResponse
  } catch (error) {
    throw Error(error)
  }
}

export interface AuthenticationResetPasswordResponse {}

export const Authentication_ResetPassword = async (req: ResetPasswordRequest): Promise<{}> => {
  try {
    const response = await api.put('/v0/auth/reset_password', req)
    return response.data as {}
  } catch (error) {
    throw Error(error)
  }
}

export interface AuthenticationSendPasswordResetEmailResponse {}

export const Authentication_SendPasswordResetEmail = async (req: SendPasswordResetEmailRequest): Promise<{}> => {
  try {
    const response = await api.post('/v0/auth/send_password_reset_email', req)
    return response.data as {}
  } catch (error) {
    throw Error(error)
  }
}

export interface BlockchainGetTransactionQueryParams {
  /**
   * The bitcoin blockchain transaction ID associated with this transaction.
   */
  network_id?: string
}

export const Blockchain_GetTransaction = async (network_id?: string): Promise<BlockchainTransaction> => {
  try {
    const response = await api.get(buildURL('/v0/blockchain/transaction', ['network_id', network_id]))
    return response.data as BlockchainTransaction
  } catch (error) {
    throw Error(error)
  }
}

export interface CurrenciesConvertQueryParams {
  /**
   * The base currency used for getting the base/quote price.
   *
   *  - BTC: BTC is the ticker for bitcoin
   */
  base_currency?: 'BTC' | 'GBP' | 'NOK' | 'USD' | 'EUR'
  /**
   * The quote currency used for getting the base/quote price.
   *
   *  - BTC: BTC is the ticker for bitcoin
   */
  quote_currency?: 'BTC' | 'GBP' | 'NOK' | 'USD' | 'EUR'
  /**
   * The amount you want to convert, measured in the base currency. Defaults
   * to 1.
   */
  amount?: number
}

export const Currencies_Convert = async (
  base_currency?: string,
  quote_currency?: string,
  amount?: number
): Promise<CurrenciesConvertResponse> => {
  try {
    const response = await api.get(
      buildURL(
        '/v0/currencies/convert',
        ['base_currency', base_currency],
        ['quote_currency', quote_currency],
        ['amount', amount]
      )
    )
    return response.data as CurrenciesConvertResponse
  } catch (error) {
    throw Error(error)
  }
}

export interface CurrenciesQuoteQueryParams {
  /**
   * Can either be buy or sell, makes the quote either a buy order or a sell
   * order.
   *
   *  - BUY: Buy bitcoin
   *  - SELL: Sell bitcoin
   */
  side?: 'BUY' | 'SELL'
  /**
   * The amount in 'currency' you want the RFQ to apply for.
   */
  amount?: number
  /**
   * Which currency the amount is denominated in.
   */
  currency?: 'GBP' | 'NOK' | 'USD' | 'EUR'
}

export const Currencies_Quote = async (
  side?: string,
  amount?: number,
  currency?: string
): Promise<CurrenciesQuoteResponse> => {
  try {
    const response = await api.get(
      buildURL('/v0/currencies/quote', ['side', side], ['amount', amount], ['currency', currency])
    )
    return response.data as CurrenciesQuoteResponse
  } catch (error) {
    throw Error(error)
  }
}

export const Exchange_RiskLimits = async (): Promise<RiskLimitsResponse> => {
  try {
    const response = await api.get(buildURL('/v0/exchange/limits'))
    return response.data as RiskLimitsResponse
  } catch (error) {
    throw Error(error)
  }
}

export const Exchange_ListSettlements = async (): Promise<ListSettlementsResponse> => {
  try {
    const response = await api.get(buildURL('/v0/exchange/settlements/list'))
    return response.data as ListSettlementsResponse
  } catch (error) {
    throw Error(error)
  }
}

export const Exchange_CreateTrade = async (req: CreateTradeRequest): Promise<Trade> => {
  try {
    const response = await api.post('/v0/exchange/trades', req)
    return response.data as Trade
  } catch (error) {
    throw Error(error)
  }
}

export interface ExchangeListTradesQueryParams {
  /**
   * The offset into the result set to retrieve from. Combined with specifying a
   * limit, allows for implementation of pagination.
   */
  offset?: number
  /**
   * How many trades to fetch. Together with specifying an offset, allows for
   * implementation of pagination. Defaults to unlimited.
   */
  limit?: number
  /**
   * Only retrieve trades that exchanged below this number of satoshis.
   */
  max_satoshi?: string
  /**
   * Only retrieve trades that exchanged above this number of satoshis.
   */
  min_satoshi?: string
  /**
   * Only retrieve trades that happened after this time.
   */
  start_time?: string
  /**
   * Only retrieve trades that happened before this time.
   */
  end_time?: string
  /**
   * The direction to sort the results.
   *
   *  - DESCENDING: Sort transactions descending, chronologically
   *  - ASCENDING: Sort transactions ascending, chronologically
   */
  sort?: 'DESCENDING' | 'ASCENDING'
  /**
   * Only include trades with this order side.
   *
   *  - BUY: Buy bitcoin
   *  - SELL: Sell bitcoin
   */
  side?: 'BUY' | 'SELL'
}

export const Exchange_ListTrades = async (
  offset?: number,
  limit?: number,
  max_satoshi?: string,
  min_satoshi?: string,
  start_time?: string,
  end_time?: string,
  sort: 'DESCENDING' | 'ASCENDING' = 'DESCENDING',
  side?: string
): Promise<ListTradesResponse> => {
  try {
    const response = await api.get(
      buildURL(
        '/v0/exchange/trades/list',
        ['offset', offset],
        ['limit', limit],
        ['max_satoshi', max_satoshi],
        ['min_satoshi', min_satoshi],
        ['start_time', start_time],
        ['end_time', end_time],
        ['sort', sort],
        ['side', side]
      )
    )
    return response.data as ListTradesResponse
  } catch (error) {
    throw Error(error)
  }
}

export interface FeesEstimateBlockchainFeesQueryParams {
  /**
   * The desired block time confirmation target. Defaults to 6.
   */
  target?: number
  /**
   * The currency the fee should be denominated in, defaults to BTC.
   *
   *  - BTC: BTC is the ticker for bitcoin
   */
  currency?: 'BTC' | 'GBP' | 'NOK' | 'USD' | 'EUR'
}

export const Fees_EstimateBlockchainFees = async (
  target?: number,
  currency?: string
): Promise<EstimateBlockchainFeesResponse> => {
  try {
    const response = await api.get(buildURL('/v0/fees/estimate/blockchain', ['target', target], ['currency', currency]))
    return response.data as EstimateBlockchainFeesResponse
  } catch (error) {
    throw Error(error)
  }
}

export interface FeesEstimateLightningFeesQueryParams {
  /**
   * The payment request to query for fees needed to pay.
   */
  lightning_request?: string
  /**
   * The currency the fee should be denominated in, defaults to BTC.
   *
   *  - BTC: BTC is the ticker for bitcoin
   */
  currency?: 'BTC' | 'GBP' | 'NOK' | 'USD' | 'EUR'
}

export const Fees_EstimateLightningFees = async (
  lightning_request?: string,
  currency?: string
): Promise<EstimateLightningFeesResponse> => {
  try {
    const response = await api.get(
      buildURL('/v0/fees/estimate/lightning', ['lightning_request', lightning_request], ['currency', currency])
    )
    return response.data as EstimateLightningFeesResponse
  } catch (error) {
    throw Error(error)
  }
}

export interface InvoicesGetQueryParams {
  /**
   * The Teslacoil UUID of the invoice you want to retrieve. This cannot be
   * set together with a transaction UUID.
   */
  id?: string
  /**
   * the ID of the linked transaction. This cannot be set with any of the
   * other fields.
   */
  transaction_id?: string
  /**
   * The Bitcoin address of the invoice you want to retrieve. This cannot be
   * set with any of the other fields.
   */
  address?: string
  /**
   * The Lightning request associated with this invoice. This cannot
   * be set with any of the other fields.
   */
  lightning_request?: string
  /**
   * The client ID associated with this invoice.
   */
  client_id?: string
}

export const Invoices_Get = async (
  id?: string,
  transaction_id?: string,
  address?: string,
  lightning_request?: string,
  client_id?: string
): Promise<Invoice> => {
  try {
    const response = await api.get(
      buildURL(
        '/v0/invoices',
        ['id', id],
        ['transaction_id', transaction_id],
        ['address', address],
        ['lightning_request', lightning_request],
        ['client_id', client_id]
      )
    )
    return response.data as Invoice
  } catch (error) {
    throw Error(error)
  }
}

export const Invoices_Create = async (req: CreateInvoiceRequest): Promise<Invoice> => {
  try {
    const response = await api.post('/v0/invoices', req)
    return response.data as Invoice
  } catch (error) {
    throw Error(error)
  }
}

export interface InvoicesListQueryParams {
  /**
   * The offset into the result set to retrieve from. Combined with specifying a
   * limit, allows for implementation of pagination.
   */
  offset?: number
  /**
   * How many invoices to fetch. Together with specifying an offset, allows
   * for implementation of pagination. Maximum value is 200.
   */
  limit?: number
  /**
   * Only retrieve invoices for maximum this amount. If this field is set, the
   * currency field must also be set.
   */
  max_amount?: number
  /**
   * Only retrieve invoices for at least this amount. If this field is set, the
   * currency field must also be set.
   */
  min_amount?: number
  /**
   * Only retrieve invoices that are denominiated in this currency.
   *
   *  - BTC: BTC is the ticker for bitcoin
   */
  currency?: 'BTC' | 'GBP' | 'NOK' | 'USD' | 'EUR'
  /**
   * Only retrieve invoices that were created at or after this time.
   */
  start_time?: string
  /**
   * Only retrieve invoices that were created at or before this time.
   */
  end_time?: string
  /**
   * Only retrieve invoices that are of this type.
   *
   *  - ONCHAIN: A transaction made on the Bitcoin blockchain
   *  - LIGHTNING: A transaction sent on the Lightning Network
   */
  type?: 'ONCHAIN' | 'LIGHTNING'
  /**
   * Only retrieve invoice which invoice status is included in the given
   * statuses. If no statuses are given, no filter is applied.
   *
   *  - UNPAID: The invoice has not received a payment
   *  - PAID: This invoice has received a payment for the exact amount we expected
   *  - OVERPAID: Money was sent, but more than we expected. The invoice can be considered
   * settled
   *  - UNDERPAID: Money was sent, but less than we expected. The invoice is not considered
   * settled.
   */
  payment_statuses?: ('UNPAID' | 'PAID' | 'OVERPAID' | 'UNDERPAID')[]
  /**
   * Only retrieve invoices that has this exact amount of transactions paying to
   * it.
   */
  transactions_count?: number
  /**
   * Only retrieve invoices that were paid before expiry.
   */
  paid_before_expiry?: boolean
  /**
   * Only retrieve invoices that are expired.
   */
  expired?: boolean
  /**
   * Which direction to order invoices.
   *
   *  - DESCENDING: Sort transactions descending, chronologically
   *  - ASCENDING: Sort transactions ascending, chronologically
   */
  sort?: 'DESCENDING' | 'ASCENDING'
  /**
   * Which property to sort transactions by.
   *
   *  - CREATE_TIME: Sort invoices chronologically. This is the default sorting property.
   *  - STATUS: Sort invoices by their payment status.
   *  - AMOUNT: Sort invoices by the amount they are for.
   */
  sort_by?: 'CREATE_TIME' | 'STATUS' | 'AMOUNT'
}

export const Invoices_List = async (
  offset?: number,
  limit?: number,
  max_amount?: number,
  min_amount?: number,
  currency?: string,
  start_time?: string,
  end_time?: string,
  type?: string,
  payment_statuses?: ('UNPAID' | 'PAID' | 'OVERPAID' | 'UNDERPAID')[],
  transactions_count?: number,
  paid_before_expiry?: boolean,
  expired?: boolean,
  sort: 'DESCENDING' | 'ASCENDING' = 'DESCENDING',
  sort_by: 'CREATE_TIME' | 'STATUS' | 'AMOUNT' = 'CREATE_TIME'
): Promise<InvoiceList> => {
  try {
    const response = await api.get(
      buildURL(
        '/v0/invoices/list',
        ['offset', offset],
        ['limit', limit],
        ['max_amount', max_amount],
        ['min_amount', min_amount],
        ['currency', currency],
        ['start_time', start_time],
        ['end_time', end_time],
        ['type', type],
        ['payment_statuses', payment_statuses],
        ['transactions_count', transactions_count],
        ['paid_before_expiry', paid_before_expiry],
        ['expired', expired],
        ['sort', sort],
        ['sort_by', sort_by]
      )
    )
    return response.data as InvoiceList
  } catch (error) {
    throw Error(error)
  }
}

export interface StatsAmountTransactedQueryParams {
  /**
   * The earliest transaction that should be included. If not set, includes
   * everything up to end time.
   */
  start_time?: string
  /**
   * The latest transaction that should be included. If not set, includes
   * everything from start time.
   */
  end_time?: string
  /**
   * The currency you want the response fiat amount to be denominated in.
   */
  currency?: 'GBP' | 'NOK' | 'USD' | 'EUR'
}

export const Stats_AmountTransacted = async (
  start_time?: string,
  end_time?: string,
  currency?: string
): Promise<AmountTransactedResponse> => {
  try {
    const response = await api.get(
      buildURL(
        '/v0/stats/amount_transacted',
        ['start_time', start_time],
        ['end_time', end_time],
        ['currency', currency]
      )
    )
    return response.data as AmountTransactedResponse
  } catch (error) {
    throw Error(error)
  }
}

export const Stats_RecentEvents = async (): Promise<RecentEventsResponse> => {
  try {
    const response = await api.get(buildURL('/v0/stats/recent_events'))
    return response.data as RecentEventsResponse
  } catch (error) {
    throw Error(error)
  }
}

export interface StatsUsageQueryParams {
  /**
   * The earliest event that should be included. If not set, includes everything
   * up to end time.
   */
  start_time?: string
  /**
   * The latest event that should be included. If not set, includes everything
   * from start time.
   */
  end_time?: string
}

export const Stats_Usage = async (start_time?: string, end_time?: string): Promise<UsageResponse> => {
  try {
    const response = await api.get(buildURL('/v0/stats/usage', ['start_time', start_time], ['end_time', end_time]))
    return response.data as UsageResponse
  } catch (error) {
    throw Error(error)
  }
}

export const System_GetLogLevels = async (): Promise<LogLevels> => {
  try {
    const response = await api.get(buildURL('/v0/system/log'))
    return response.data as LogLevels
  } catch (error) {
    throw Error(error)
  }
}

export const System_SetLogLevels = async (req: SetLogLevelsRequest): Promise<LogLevels> => {
  try {
    const response = await api.patch('/v0/system/log', req)
    return response.data as LogLevels
  } catch (error) {
    throw Error(error)
  }
}

export interface SystemPingResponse {}

export const System_Ping = async (): Promise<{}> => {
  try {
    const response = await api.get(buildURL('/v0/system/ping'))
    return response.data as {}
  } catch (error) {
    throw Error(error)
  }
}

export interface SystemShutdownResponse {}

export interface TeslaPayGetDepositQueryParams {
  /**
   * The Teslacoil ID of the deposit.
   */
  id?: string
}

export const TeslaPay_GetDeposit = async (id?: string): Promise<TeslaPayDeposit> => {
  try {
    const response = await api.get(buildURL('/v0/teslapay/deposit', ['id', id]))
    return response.data as TeslaPayDeposit
  } catch (error) {
    throw Error(error)
  }
}

export interface TeslaPayGetWithdrawalQueryParams {
  /**
   * The Teslacoil ID of the withdrawal.
   */
  id?: string
}

export const TeslaPay_GetWithdrawal = async (id?: string): Promise<TeslaPayWithdrawal> => {
  try {
    const response = await api.get(buildURL('/v0/teslapay/withdrawal', ['id', id]))
    return response.data as TeslaPayWithdrawal
  } catch (error) {
    throw Error(error)
  }
}

export interface TransactionsGetTransactionQueryParams {
  /**
   * The Teslacoil ID of this transaction.
   */
  id?: string
  /**
   * The client ID associated with this transaction.
   */
  client_id?: string
}

export const Transactions_GetTransaction = async (id?: string, client_id?: string): Promise<Transaction> => {
  try {
    const response = await api.get(buildURL('/v0/transactions', ['id', id], ['client_id', client_id]))
    return response.data as Transaction
  } catch (error) {
    throw Error(error)
  }
}

export interface TransactionsGetLightningQueryParams {
  /**
   * The Teslacoil ID of the transaction you want to get.
   */
  id?: string
  /**
   * The Lightning request of the transaction you want to get.
   */
  lightning_request?: string
}

export const Transactions_GetLightning = async (
  id?: string,
  lightning_request?: string
): Promise<LightningTransaction> => {
  try {
    const response = await api.get(
      buildURL('/v0/transactions/lightning', ['id', id], ['lightning_request', lightning_request])
    )
    return response.data as LightningTransaction
  } catch (error) {
    throw Error(error)
  }
}

export interface TransactionsDecodeLightningQueryParams {
  /**
   * The Lightning request you want to decode.
   */
  lightning_request?: string
}

export const Transactions_DecodeLightning = async (lightning_request?: string): Promise<DecodeLightningResponse> => {
  try {
    const response = await api.get(
      buildURL('/v0/transactions/lightning/decode', ['lightning_request', lightning_request])
    )
    return response.data as DecodeLightningResponse
  } catch (error) {
    throw Error(error)
  }
}

export const Transactions_SendLightning = async (req: SendLightningRequest): Promise<SendTransactionResponse> => {
  try {
    const response = await api.post('/v0/transactions/lightning/send', req)
    return response.data as SendTransactionResponse
  } catch (error) {
    throw Error(error)
  }
}

export interface TransactionsListTransactionsQueryParams {
  /**
   * The offset into the result set to retrieve from. Combined with specifying a
   * limit, allows for implementation of pagination.
   */
  offset?: number
  /**
   * How many transactions to fetch. Together with specifying an offset, allows
   * for implementation of pagination.
   */
  limit?: number
  /**
   * Only retrieve transactions that spent or received below this number of
   * satoshis.
   */
  max_satoshi?: string
  /**
   * Only retrieve transactions that spent or received above this number of
   * satoshis.
   */
  min_satoshi?: string
  /**
   * Only retrieve transactions that were sent or received after this time.
   */
  start_time?: string
  /**
   * Only retrieve transactions that were sent or received before this time.
   */
  end_time?: string
  /**
   * Only retrieve transactions that match this direction.
   *
   *  - INCOMING: Received to Teslacoil, a deposit
   *  - OUTGOING: Sent from Teslacoil, a withdrawal
   */
  direction?: 'INCOMING' | 'OUTGOING'
  /**
   * Which direction to sort transactions.
   *
   *  - DESCENDING: Sort transactions descending, chronologically
   *  - ASCENDING: Sort transactions ascending, chronologically
   */
  sort?: 'DESCENDING' | 'ASCENDING'
  /**
   * Which property to sort transactions by.
   *
   *  - CREATE_TIME: Sort transactions chronologically. This is the default sorting property.
   *  - STATUS: Sort invoices by their status.
   *  - AMOUNT: Sort invoices by their size.
   */
  sort_by?: 'CREATE_TIME' | 'STATUS' | 'AMOUNT'
  /**
   * Specifies if this transaction was made over Lightning or on-chain.
   *
   *  - ONCHAIN: A transaction made on the Bitcoin blockchain
   *  - LIGHTNING: A transaction sent on the Lightning Network
   */
  network_type?: 'ONCHAIN' | 'LIGHTNING'
  /**
   * Include transactions having one of the provided statuses. If no statuses
   * are set, no filter is applied.
   *
   *  - PENDING: The transaction has not reached a conclusion whether it's completed or
   * failed yet
   *  - COMPLETED: The transaction has been received by the recipient, and is settled.
   *  - FAILED: The transaction has failed
   */
  statuses?: ('PENDING' | 'COMPLETED' | 'FAILED')[]
  /**
   * include transactions made as part of trading settlements.
   */
  include_settlements?: boolean
}

export const Transactions_ListTransactions = async (
  offset?: number,
  limit?: number,
  max_satoshi?: string,
  min_satoshi?: string,
  start_time?: string,
  end_time?: string,
  direction?: string,
  sort: 'DESCENDING' | 'ASCENDING' = 'DESCENDING',
  sort_by: 'CREATE_TIME' | 'STATUS' | 'AMOUNT' = 'CREATE_TIME',
  network_type?: string,
  statuses?: ('PENDING' | 'COMPLETED' | 'FAILED')[],
  include_settlements?: boolean
): Promise<ListTransactionsResponse> => {
  try {
    const response = await api.get(
      buildURL(
        '/v0/transactions/list',
        ['offset', offset],
        ['limit', limit],
        ['max_satoshi', max_satoshi],
        ['min_satoshi', min_satoshi],
        ['start_time', start_time],
        ['end_time', end_time],
        ['direction', direction],
        ['sort', sort],
        ['sort_by', sort_by],
        ['network_type', network_type],
        ['statuses', statuses],
        ['include_settlements', include_settlements]
      )
    )
    return response.data as ListTransactionsResponse
  } catch (error) {
    throw Error(error)
  }
}

export interface TransactionsGetOnchainQueryParams {
  /**
   * The Teslacoil ID of this transaction.
   */
  id?: string
  /**
   * The client ID associated with this transaction.
   */
  client_id?: string
  /**
   * The bitcoin blockchain transaction ID associated with this transaction.
   */
  network_id?: string
}

export const Transactions_GetOnchain = async (
  id?: string,
  client_id?: string,
  network_id?: string
): Promise<OnchainTransaction> => {
  try {
    const response = await api.get(
      buildURL('/v0/transactions/onchain', ['id', id], ['client_id', client_id], ['network_id', network_id])
    )
    return response.data as OnchainTransaction
  } catch (error) {
    throw Error(error)
  }
}

export const Transactions_SendOnchain = async (req: SendOnchainRequest): Promise<SendTransactionResponse> => {
  try {
    const response = await api.post('/v0/transactions/onchain/send', req)
    return response.data as SendTransactionResponse
  } catch (error) {
    throw Error(error)
  }
}

export interface TransactionsCancelPreparedTransactionResponse {}

export interface TransactionsCancelPreparedTransactionQueryParams {
  /**
   * The Teslacoil ID of this prepared transaction;.
   */
  id?: string
}

export const Transactions_CancelPreparedTransaction = async (id?: string): Promise<{}> => {
  try {
    const response = await api.delete(buildURL('/v0/transactions/prepare', ['id', id]))
    return response.data as {}
  } catch (error) {
    throw Error(error)
  }
}

export interface TransactionsGetPreparedTransactionQueryParams {
  /**
   * The Teslacoil ID of this prepared transaction;.
   */
  id?: string
}

export const Transactions_GetPreparedTransaction = async (id?: string): Promise<PreptxPreparation> => {
  try {
    const response = await api.get(buildURL('/v0/transactions/prepare', ['id', id]))
    return response.data as PreptxPreparation
  } catch (error) {
    throw Error(error)
  }
}

export const Transactions_PrepareTransaction = async (req: PreptxPrepareRequest): Promise<PreptxPreparation> => {
  try {
    const response = await api.post('/v0/transactions/prepare', req)
    return response.data as PreptxPreparation
  } catch (error) {
    throw Error(error)
  }
}

export const Transactions_ExecutePreparedTransaction = async (
  req: PreptxExecuteRequest
): Promise<PreptxPreparation> => {
  try {
    const response = await api.post('/v0/transactions/prepare/execute', req)
    return response.data as PreptxPreparation
  } catch (error) {
    throw Error(error)
  }
}

export interface TransactionsGetLnUrlPreparedTransactionQueryParams {
  /**
   * The secret generated when creating initating withdrawal.
   */
  secret?: string
}

export const Transactions_GetLnUrlPreparedTransaction = async (
  secret?: string
): Promise<LnurlGetWithdrawalResponse> => {
  try {
    const response = await api.get(buildURL('/v0/transactions/prepare/lnurl', ['secret', secret]))
    return response.data as LnurlGetWithdrawalResponse
  } catch (error) {
    throw Error(error)
  }
}

export interface TransactionsExecuteLnUrlPreparedTransactionQueryParams {
  /**
   * The generated secret specific to this LNURL Withdrawal.
   */
  k1?: string
  /**
   * The lightning request teslacoil should pay to complete the LNURL
   * withdrawal.
   */
  pr?: string
}

export const Transactions_ExecuteLnUrlPreparedTransaction = async (
  k1?: string,
  pr?: string
): Promise<LnurlExecuteWithdrawalResponse> => {
  try {
    const response = await api.get(buildURL('/v0/transactions/prepare/lnurl/execute', ['k1', k1], ['pr', pr]))
    return response.data as LnurlExecuteWithdrawalResponse
  } catch (error) {
    throw Error(error)
  }
}

export const Users_CreateUser = async (req: CreateUserRequest): Promise<User> => {
  try {
    const response = await api.post('/v0/users', req)
    return response.data as User
  } catch (error) {
    throw Error(error)
  }
}

export interface UsersUpdateUserResponse {}

export const Users_UpdateUser = async (req: UpdateUserRequest): Promise<{}> => {
  try {
    const response = await api.put('/v0/users', req)
    return response.data as {}
  } catch (error) {
    throw Error(error)
  }
}
