/* eslint-disable */

import axios from 'axios'

const api = axios.create({
  validateStatus: () => true,
})

const apiKeyNotSetMessage = "looks like you haven't set your api-key! set api-key by calling setCredentials(key)"
type environments = 'MAINNET' | 'TESTNET' | 'REGTEST'
let apiKey = ''

export const setCredentials = (key: string, network: environments = 'REGTEST'): void => {
  if (key === '') {
    throw Error('api key can not be set to empty string')
  }

  apiKey = key
  switch (network) {
    case 'MAINNET':
      api.defaults.baseURL = 'https://api.teslacoil.io'
      break
    case 'TESTNET':
      api.defaults.baseURL = 'https://testnetapi.teslacoil.io'
      break
    case 'REGTEST':
      api.defaults.baseURL = 'http://localhost:5000'
      break
  }
  api.defaults.timeout = 5000
  api.defaults.headers = { Authorization: apiKey }
}

/* Generated by restful-react */

export interface Account {
  auto_exchange_currency?: FiatcurrencyFiatCurrency
  balance_bitcoin?: number
  balance_satoshi?: string
  id?: string
  name?: string
}

/**
 * Information describing a user and its relation to an account.
 */
export interface AccountUser {
  account_id: string
  account_name: string
  admin: boolean
  auto_exchange_currency?: FiatcurrencyFiatCurrency
  balance_bitcoin: number
  balance_satoshi: string
  create_time: string
  email: string
  first_name: string
  has_changed_password: boolean
  has_confirmed_2fa: boolean
  last_login_time: string
  last_name: string
  owner: boolean
  permissions: Permissions
  update_time: string
  user_id: string
  user_preferred_display_currency: CryptoCurrencyFormat
}

export interface AccountingTransaction {
  complete_time?: string
  direction?: TransactionDirection
  id?: string
  inbound_milli_sat?: string
  invoice_description?: string
  invoice_id?: string
  memo?: string
  network_fee_milli_sat?: string
  network_type?: NetworkType
  outbound_milli_sat?: string
  transaction_description?: string
}

/**
 * Response from the amount transacted endpoint.
 */
export interface AmountTransactedResponse {
  amount_transacted_fiat: number
  amount_transacted_satoshi: string
}

export interface ApiKey {
  account_id: string
  create_time: string
  /**
   * The description (if any) associated with this key.
   */
  description: string
  expiry_time?: string
  /**
   * The hashed API key. API keys are not stored in cleartext in the database,
   * but compared against a hash. The user is only shown their API key once, and
   * Teslacoil is unable to retrieve it in cleartext again.
   */
  hashed_key: string
  /**
   * The last letters of the API key. This is stored so it is easier to
   * identify a specific key in a list of all keys.
   */
  last_letters: string
  last_use_time?: string
  permissions: Permissions
  whitelisted_ips: string[]
}

export interface BitcoinPrice {
  /**
   * The price of 1 BTC, expressed in USD.
   */
  price?: string
  /**
   * The timestamp for this price price provided.
   */
  price_timestamp?: string
}

/**
 * Description of event that triggered callback
 */
export type CallbackEvent = string

/**
 * Identifier for callback types
 */
export type CallbackIdentifier =
  | 'lightning-invoice'
  | 'onchain-invoice'
  | 'onchain-transaction'
  | 'lightning-transaction'

export interface ChangePasswordRequest {
  /**
   * The new user password. This is a required field.
   */
  new_password: string
  /**
   * The old user password. This is a required field.
   */
  old_password: string
  /**
   * The new user password, again. This field should be populated with the text
   * from a different field than the first new password. This is a required
   * field.
   */
  repeated_new_password: string
}

export interface CompleteLNURLWithdrawResponse {
  status?: string
  transaction_id?: string
}

export interface Confirm2faRequest {
  /**
   * A 2FA code the user generated with their authenticator app. This is a
   * required field.
   */
  code: string
}

export interface Create2faResponse {
  /**
   * A 2FA secret the user can input into their authenticator app to
   * generate 2FA codes.
   */
  totp_secret: string
}

export interface CreateAccountRequest {
  name: string
}

export interface CreateApiKeyRequest {
  /**
   * An optional description of your API key. We highly recommend including
   * this, as it makes it much easier to identify a specific key later on.
   */
  description?: string
  expiry_time?: string
  permissions?: Permissions
  whitelisted_ips?: string[]
}

export interface CreateApiKeyResponse {
  key: string
  key_information: ApiKey
}

/**
 * The available fields for creating an invoice.
 */
export interface CreateInvoiceRequest {
  /**
   * The amount you want your created invoice to be for, measured in the
   * currency you specify.
   * This is a required field, and cannot be less than or equal to zero.
   */
  amount?: number
  /**
   * An (optional) callback URL to associate with this invoice. When the
   * invoice receives payment, we send a POST request to this URL to notify
   * you.
   */
  callback_url?: string
  /**
   * An (optional) ID you can associate with this invoice. This is never
   * used by Teslacoil, other than to identify your invoice when notifying
   * you of updates, as well as letting you retrieve the invoice by this ID.
   * We wont validate that this ID is unique to your invoice. So if you
   * want to use this field to later retrieve an invoice, you will have to
   * make sure yourself that it only identifies a single element.
   */
  client_id?: string
  currency?: CurrencyCurrency
  customer_company?: string
  customer_email?: string
  /**
   * An (optional) description to associate with this invoice. This is only
   * visible to the creator of the invoice.
   */
  description?: string
  exchange_currency?: FiatcurrencyFiatCurrency
  /**
   * The expiry of this invoice. Defaults to 1 hour, if not
   * set or set to zero. It is still possible for the user to send money to the
   * address associated with this invoice, but it will not make it count as
   * settled.
   */
  expiry_seconds?: number
  /**
   * An optional description to encode into the Lightning request
   * associated with this invoice. This is publicly visible. If creating an
   * on-chain invoice, setting this field has no effect.
   */
  lightning_memo?: string
}

export interface CreateLNURLWithdrawRequest {
  custom_complete_url?: string
  /**
   * if set, will make sure the lnurl withdrawal can't be completed after a set
   * time defaults to 3600 (1 hour).
   */
  expiry_seconds?: number
  /**
   * An optional description used to request the caller of this request to
   * encode this field in the generated lightning request.
   */
  lightning_request_memo?: string
  max_withdrawable_milli_satoshi?: string
  /**
   * Minimum amount allowed to withdraw using the generated secret. If not set,
   * defaults to 0.
   */
  min_withdrawable_milli_satoshi?: string
}

/**
 * Contains all necessary information to show a lnurl withdrawal QR code to the
 * user.
 */
export interface CreateLNURLWithdrawResponse {
  k1_secret?: string
  /**
   * An encoded lnurl containing a link to GET more information about the
   * withdrawal, including the secret.
   */
  lnurl?: string
}

/**
 * Possible parameters when creating a trade.
 */
export interface CreateTradeRequest {
  amount?: number
  quote?: FiatcurrencyFiatCurrency
  side?: OrderSide
}

export interface CreateUserRequest {
  /**
   * The email of the user you want to create. This is a required field. After
   * the user is created, we'll send a message to this email address. The user
   * will then have to verify their address by clicking on a link in said email.
   * Until this is done, the user cannot sign in or otherwise use Teslacoil.
   * Until the user has activated 2FA and changed their password, it only has
   * very limited access to teslacoil.
   */
  email?: string
  first_name?: string
  last_name?: string
}

export interface CreatedInvoiceEvent {
  /**
   * The amount of this invoice, denominated in the currency.
   */
  amount: number
  currency: CurrencyCurrency
}

export interface CreatedTradeEvent {
  /**
   * The fiat amount traded, denominated in the currency.
   */
  amount_fiat: number
  amount_satoshi: string
  currency: FiatcurrencyFiatCurrency
  side: OrderSide
  /**
   * What (if any) transaction this trade relates to.
   */
  transaction_id?: string
}

/**
 * - BITCOIN: Whole units of bitcoin
 *  - SATOSHIS: 1/100 000 000 of a bitcoin
 */
export type CryptoCurrencyFormat = 'BITCOIN' | 'SATOSHIS'

export interface CurrenciesConvertResponse {
  /**
   * amount is the quote amount per base amount.
   */
  amount: number
  base_currency: CurrencyCurrency
  quote_currency: CurrencyCurrency
}

export interface CurrenciesQuoteResponse {
  amount_btc: number
  amount_satoshi: number
  base_currency: CurrencyCurrency
  quote_currency: CurrencyCurrency
  rate: number
}

export interface DecodeLightningResponse {
  amount_satoshi?: string
  destination?: string
  expire_time?: string
  fallback_onchain_address?: string
  memo?: string
  /**
   * The hash of the preimage.
   */
  payment_hash?: string
}

/**
 *  - LOCAL_CHANNEL_OPEN: A channel opening transaction for a channel opened by our node.
 *  - REMOTE_CHANNEL_OPEN: A channel opening transaction for a channel opened by a remote node.
 *  - CHANNEL_OPEN_FEE: The on chain fee paid to open a channel.
 *  - CHANNEL_CLOSE: A channel closing transaction.
 *  - RECEIPT: Receipt of funds. On chain this reflects receives, off chain settlement
 * of invoices.
 *  - PAYMENT: Payment of funds. On chain this reflects sends, off chain settlement
 * of our payments.
 *  - FEE: Payment of fees.
 *  - CIRCULAR_RECEIPT: Receipt of a payment to ourselves.
 *  - FORWARD: A forward through our node.
 *  - FORWARD_FEE: Fees earned from forwarding.
 *  - CIRCULAR_PAYMENT: Sending of a payment to ourselves.
 *  - CIRCULAR_FEE: The fees paid to send an off chain payment to ourselves.
 *  - SWEEP: A transaction that sweeps funds back into our wallet's control.
 *  - SWEEP_FEE: The amount of fees paid for a sweep transaction.
 *  - CHANNEL_CLOSE_FEE: The fees paid to close a channel.
 */
export type EntryType =
  | 'UNKNOWN'
  | 'LOCAL_CHANNEL_OPEN'
  | 'REMOTE_CHANNEL_OPEN'
  | 'CHANNEL_OPEN_FEE'
  | 'CHANNEL_CLOSE'
  | 'RECEIPT'
  | 'PAYMENT'
  | 'FEE'
  | 'CIRCULAR_RECEIPT'
  | 'FORWARD'
  | 'FORWARD_FEE'
  | 'CIRCULAR_PAYMENT'
  | 'CIRCULAR_FEE'
  | 'SWEEP'
  | 'SWEEP_FEE'
  | 'CHANNEL_CLOSE_FEE'

export interface EstimateBlockchainFeesResponse {
  average_fee: number
  currency: CurrencyCurrency
  sats_per_byte: number
}

export interface EstimateLightningFeesResponse {
  currency: CurrencyCurrency
  fee: number
}

/**
 * Contains the information you get about each activity. It will always have
 * exactly one event.
 */
export interface Event {
  created_invoice?: CreatedInvoiceEvent
  created_trade?: CreatedTradeEvent
  description?: string
  event_id: string
  incoming_transaction?: IncomingTransactionEvent
  invoice_status_change?: InvoiceStatusChangeEvent
  sent_lightning_transaction?: SentLightningTransactionEvent
  sent_onchain_transaction?: SentOnchainTransactionEvent
  time: string
}

export interface GetJwtRequest {
  /**
   * The ID or name of the account that the JWT will be valid for. If not set,
   * the JWT is only valid for certain user-related endpoints.
   */
  account_identifier?: string
  /**
   * The email of the user that's requesting a JWT. This is a required field.
   */
  email: string
  /**
   * The password of the user that's requesting a JWT. This is a required field.
   */
  password: string
  /**
   * The 2FA code to use when requesting a JWT. If 2FA is enabled, this is a
   * required field.
   */
  totp_code?: string
}

export interface GetJwtResponse {
  /**
   * The created JWT. This can be used to authenticate against the API, by
   * prefixing it with "Bearer " and placing in the authorization header.
   */
  token: string
}

export interface GiveAccessRequest {
  permissions?: Permissions
  user_id?: string
}

export interface IncomingTransactionEvent {
  amount_satoshi: string
}

/**
 * An invoice that contains all the fields that a Lightning and an on-chain
 * invoice has in common. It also contains a type parameter which indicates
 * whether it is a Lightning invoice or an on-chain invoice.
 */
export interface Invoice {
  /**
   * The account that created this invoice.
   */
  account_id: string
  /**
   * How much this invoice has received in payments, so far. This is measured in
   * whole lots of the currency associated with this invoice.
   */
  amount_paid: number
  /**
   * The bitcoin address (if any) associated with this invoice.
   */
  bitcoin_address: string
  /**
   * The callback URL associated with this invoice, if any.
   */
  callback_url: string
  /**
   * An (optional) ID you associated with this invoice. This is never
   * used by Teslacoil, other than to identify your invoice when notifying
   * you of updates, as well as letting you retrieve the transaction by this
   * ID. We wont validate that this ID is unique to your invoices. So if you
   * want to use this field to later retrieve a invoice, you will have to
   * make sure yourself that it only identifies a single element.
   */
  client_id: string
  /**
   * When this invoice was created.
   */
  create_time: string
  currency: CurrencyCurrency
  /**
   * The company of the customer that is expect to pay this invoice.
   */
  customer_company: string
  /**
   * The email of the customer that is expect to pay this invoice.
   */
  customer_email: string
  /**
   * The description associated with this invoice, if any.
   */
  description: string
  exchange_currency?: FiatcurrencyFiatCurrency
  /**
   * How long this invoice is valid for, measured in seconds. If this invoice
   * has an associated Lightning request, it is not to possible to pay
   * it after the invoice is expired. If it has a bitcoin address associated
   * with it, it is
   *  still possible to send money to the associated bitcoin address after the
   *  invoices is expired, but it will not cause the invoice to become settled.
   */
  expiry_seconds: number
  /**
   * The Teslacoil ID for this invoice.
   */
  id: string
  lightning_request: string
  /**
   * Whether this invoice received sufficient payment before it expired or not.
   */
  paid_before_expiry: boolean
  payment_status: InvoiceStatus
  /**
   * The amount of money requested in this invoice. It is measured in whole lots
   * of the currency field. If the currency is set to BTC, this field is going
   * to equal the field for how much BTC was requested.
   */
  requested_amount: number
  /**
   * The requested amount of money, measured in bitcoin. This is calculated when
   * fetching the invoice, based on current exchange rates.
   */
  requested_amount_bitcoin: number
  /**
   * The requested amount of money, measured in satoshis. This is calculated
   * when fetching the invoice, based on current exchange rates.
   */
  requested_amount_satoshi: string
  /**
   * When this invoice was settled, if at all.
   */
  settle_time?: string
  /**
   * The IDs of the transaction that settled this invoice. Length is 0 if the
   * invoice isn't settled.
   */
  transaction_ids: string[]
}

export interface InvoiceList {
  invoices: Invoice[]
  total: number
}

/**
 * - UNPAID: The invoice has not received a payment
 *  - PAID: This invoice has received a payment for the exact amount we expected
 *  - OVERPAID: Money was sent, but more than we expected. The invoice can be considered
 * settled
 *  - UNDERPAID: Money was sent, but less than we expected. The invoice is not considered
 * settled.
 */
export type InvoiceStatus = 'UNPAID' | 'PAID' | 'OVERPAID' | 'UNDERPAID'

export interface InvoiceStatusChangeEvent {
  /**
   * the amount of the invoice, denominated in the currency.
   */
  amount_fiat: number
  /**
   * How much this invoice has received in payments, so far. This is measured in
   * whole lots of the currency associated with this invoice.
   */
  amount_paid: number
  currency: CurrencyCurrency
  invoice_id: string
  invoice_status: InvoiceStatus
}

/**
 * Contains all necessary information to prefill the users wallet with info, and
 * complete the withdrawal.
 */
export interface LNURLWithdrawResponse {
  callback?: string
  defaultDescription?: string
  k1?: string
  maxWithdrawable?: string
  minWithdrawable?: string
  tag?: string
}

export interface LightningTransaction {
  amount_bitcoin: number
  amount_satoshi: string
  /**
   * The URL to hit when the status of this transaction changes.
   */
  callback_url: string
  /**
   * Every transaction can have a client ID associated to it. This is not used
   * by Teslacoil, but can be used to correlate transactions with your internal
   * database when handling callbacks and other interactions with the Teslacoil
   * API.
   */
  client_id: string
  /**
   * The creation time of this transaction.
   */
  create_time: string
  /**
   * An internal description associated with this transaction. This is only
   * visible to the creator of the transaction.
   */
  description: string
  direction: TransactionDirection
  /**
   * The hashed preimage of this transaction.
   */
  hashed_preimage: string
  id: string
  invoice_id?: string
  /**
   * The lightning request belonging to this transactions. All Lightning
   * transactions have a lightning request associated with them. Lightning
   * requests specify the recipient and amount of a transaction, as well as
   * other, optional, information.
   */
  lightning_request: string
  /**
   * The encoded lightning request description of this transaction. This is
   * encoded into the lightning request, and is publicly visible.
   */
  memo: string
  network_fee_bitcoin: number
  network_fee_satoshi: string
  /**
   * If the lightning payment failed, this field specifies why this happened.
   */
  payment_error: string
  /**
   * The preimage of this transaction, if any. Preimages for transactions are
   * only available if they are settled.
   */
  preimage: string
  /**
   * The settlement time of this transaction. This is only available for
   * completed transactions.
   */
  settlement_time: string
  status: TransactionStatus
}

export interface ListAccountNamesResponse {
  names: string[]
}

export interface ListAccountsResponse {
  accounts: Account[]
}

export interface ListApiKeysResponse {
  keys: ApiKey[]
}

export interface ListSettlementsResponse {
  settlements: Settlement[]
  total: number
}

export interface ListTradesResponse {
  total: number
  trades: Trade[]
}

export interface ListTransactionsResponse {
  /**
   * How many transactions matched the filtering options sent. Can be used to
   * implement pagination client-side.
   */
  total: number
  transactions: Transaction[]
}

/**
 * - ONCHAIN: A transaction made on the Bitcoin blockchain
 *  - LIGHTNING: A transaction sent on the Lightning Network
 */
export type NetworkType = 'ONCHAIN' | 'LIGHTNING'

export interface NodeAuditResponse {
  /**
   * On chain reports for the period queried.
   */
  reports?: ReportEntry[]
}

export interface OnchainTransaction {
  /**
   * The address this transaction was sent to. If this is an outgoing
   * transaction, this is the recipient. If this as incoming, it is our deposit
   * address.
   */
  address: string
  /**
   * How much this transaction was for, i.e. how much it credited/debited the
   * account. Measured in bitcoin.
   */
  amount_bitcoin: number
  /**
   * How much this transaction was for, i.e. how much it credited/debited the
   * account. Measured in satoshis.
   */
  amount_satoshi: string
  /**
   * The URL, if any, to send updates to whenever events related to this
   * transaction occurs.
   */
  callback_url: string
  /**
   * Every transaction can have a client ID associated to it. This is not used
   * by Teslacoil, but can be used to correlate transactions with your internal
   * database when handling callbacks and other interactions with the Teslacoil
   * API.
   */
  client_id: string
  /**
   * If this transaction is confirmed, this is the block height that the
   * transaction was confirmed at.
   */
  confirmation_block_height: string
  /**
   * If this transaction is confirmed, this is the time that the transaction was
   * confirmed.
   */
  confirmation_time: string
  /**
   * Whether or not this transaction has been confirmed by being placed into the
   * Bitcoin blockchain. This does not happen immediately after a transaction is
   * made, because a Bitcoin miner needs to process it first.
   */
  confirmed: boolean
  /**
   * When this transaction was created.
   */
  create_time: string
  description: string
  direction: TransactionDirection
  /**
   * The internal Teslacoil ID of this transaction. Can be used to retrieve the
   * transaction at a later point in time.
   */
  id: string
  invoice_id?: string
  /**
   * How much fees we paid to the bitcoin miners for this transaction. Not set
   * if this transaction was sent to us, as we can't know that.
   */
  network_fee_bitcoin: number
  /**
   * How much fees we paid to the bitcoin miners for this transaction. Not set
   * if this transaction was sent to us, as we can't know that.
   */
  network_fee_satoshi: string
  /**
   * The Bitcoin network transaction ID of this transaction. This can be used to
   * look up the transaction in a block explorer or a Bitcoin node.
   */
  transaction_id: string
  /**
   * The output index of the underlying Bitcoin transaction that this specfic
   * transfer of funds refer to.
   */
  transaction_output: string
}

/**
 * The valid sides for a trade. Used in getting a RFQ (request for quote), and
 * creating and describing trades.
 *
 *  - BUY: Buy bitcoin
 *  - SELL: Sell bitcoin
 */
export type OrderSide = 'BUY' | 'SELL'

export interface Permissions {
  accounting: Privileges
  accounts: Privileges
  api_keys: Privileges
  auth: Privileges
  currencies: Privileges
  exchange: Privileges
  experimental: Privileges
  invoices: Privileges
  system: Privileges
  transactions: Privileges
  users: Privileges
}

export interface Privileges {
  create: boolean
  delete: boolean
  read: boolean
  update: boolean
}

export interface RecentEventsResponse {
  events?: Event[]
}

export interface ReportEntry {
  /**
   * The amount of the entry, expressed in millisatoshis.
   */
  amount?: string
  /**
   * The asset affected by the entry.
   */
  asset?: string
  btc_price?: BitcoinPrice
  /**
   * Whether the entry is a credit or a debit.
   */
  credit?: boolean
  /**
   * The fiat amount of the entry's amount in USD.
   */
  fiat?: string
  /**
   * An additional note for the entry, providing additional context.
   */
  note?: string
  /**
   * Whether the entry occurred on chain or off chain.
   */
  on_chain?: boolean
  /**
   * A unique identifier for the entry, if available.
   */
  reference?: string
  /**
   * The unix timestamp of the event.
   */
  timestamp?: string
  /**
   * The transaction id of the entry.
   */
  txid?: string
  type?: EntryType
}

export interface ResetPasswordRequest {
  /**
   * The users password. This is a required field.
   */
  password?: string
  /**
   * The users password resset token, obtained through requesting one being sent
   * to the users email. This is a required field.
   */
  token?: string
}

export interface RestError {
  error?: RestErrorContent
}

export interface RestErrorContent {
  details?: { [key: string]: any }[]
  docs?: string
  message?: string
  status?: string
}

export interface RiskLimitsResponse {
  [key: string]: any
}

export interface SendLightningRequest {
  /**
   * The URL we send a POST request to when the transaction is completed.
   */
  callback_url?: string
  /**
   * An (optional) ID you associated with this transaction. This is never
   * used by Teslacoil, other than to identify your transaction when notifying
   * you of updates, as well as letting you retrieve the transaction by this
   * ID. We wont validate that this ID is unique to your transaction. So if you
   * want to use this field to later retrieve a transaction, you will have to
   * make sure yourself that it only identifies a single element.
   */
  client_id?: string
  /**
   * An optional description to associate with this transaction. This is only
   * visible to the sender of this request.
   */
  description?: string
  lightning_request?: string
}

export interface SendOnchainRequest {
  /**
   * The destination bitcoin address. Must be set.
   */
  address?: string
  /**
   * The amount to send, denominated in the currency supplied.
   * Cannot be zero or negative.
   */
  amount?: number
  /**
   * The URL, if any, to send updates to whenever events related to this
   * transaction occurs.
   */
  callback_url?: string
  /**
   * An (optional) ID you can associate with this transaction. This is never
   * used by Teslacoil, other than to identify your transaction when notifying
   * you of updates, as well as letting you retrieve the transaction by this ID.
   * We wont validate that this ID is unique to your transactions. So if you
   * want to use this field to later retrieve a transaction, you will have to
   * make sure yourself that it only identifies a single element.
   */
  client_id?: string
  currency?: CurrencyCurrency
  /**
   * An (optional) description to associate with this transaction. Only visible
   * to the sender of the transaction.
   */
  description?: string
  /**
   * If set, we use this as the fee rate for your transaction, measured in
   * satoshi per (virtual) byte.
   */
  fee_satoshi_per_byte?: number
  /**
   * If set, we try and construct the transaction such that it is confirmed by
   * this number of blocks. A higher value here means a lower network fee, but
   * you will have to wait longer until the transaction is included in the
   * blockchain. A lower value would make your transaction confirm quicker, but
   * it would be more expensive.
   */
  target_confirmation?: number
}

export interface SendPasswordResetEmailRequest {
  /**
   * The email the user signed up with. This is a required field.
   */
  email?: string
}

/**
 * The fields returned when a transaction was successfully initiated.
 * It does not include specific information about the transaction for security
 * purposes, as there are several steps payment must go through before it is
 * sent which might take some time. You can poll for the latest updates using
 * the provided url.
 */
export interface SendTransactionResponse {
  id?: string
  url?: string
}

export interface SentLightningTransactionEvent {
  amount_satoshi: string
}

export interface SentOnchainTransactionEvent {
  amount_satoshi: string
}

/**
 * A settlement represents the finalization of trades performed at a prior time.
 * The parties transfer funds to each other to settle their debts.
 */
export interface Settlement {
  amount?: number
  create_time?: string
  currency?: CurrencyCurrency
  direction?: TransactionDirection
  /**
   * Whether or not this settlement is considered finished. It is considered
   * finished if all parties have sent and received the sums agreed upon.
   */
  done?: boolean
  /**
   * When, if any, this settlement was finalized.
   */
  finalize_time?: string
  id?: string
  transactions?: Transaction[]
}

/**
 * - DESCENDING: Sort transactions descending, chronologically
 *  - ASCENDING: Sort transactions ascending, chronologically
 */
export type SortingDirection = 'DESCENDING' | 'ASCENDING'

export interface Statement {
  account_id?: string
  closing_balance_milli_sat?: string
  end_time?: string
  inbound_milli_sat?: string
  network_fee_milli_sat?: string
  opening_balance_milli_sat?: string
  outbound_milli_sat?: string
  start_time?: string
  transactions?: AccountingTransaction[]
}

export interface TeslaPayInvoice {
  /**
   * The invoice amount, denominated in the currency returned.
   */
  amount?: number
  /**
   * The bitcoin amount expected to be received given the current exchange rate.
   */
  amount_bitcoin?: number
  /**
   * How much this invoice has received in payments, so far. This is measured in
   * whole lots of the currency associated with this invoice.
   */
  amount_paid?: number
  /**
   * The bitcoin address associated with this invoice.
   */
  bitcoin_address?: string
  currency?: CurrencyCurrency
  /**
   * the custom order ID associated with this invoice.
   */
  custom_order_id?: string
  /**
   * The company of the customer that is expect to pay this invoice.
   */
  customer_company?: string
  /**
   * An (optional) description that was associated with this invoice.
   */
  description?: string
  /**
   * What time this invoice is expired and can no longer be paid.
   */
  expire_time?: string
  expired?: boolean
  /**
   * The lightning request associated with this invoice.
   */
  lightning_request?: string
  /**
   * Your company name.
   */
  recipient?: string
  /**
   * When this invoice was settled, if at all.
   */
  settle_time?: string
  status?: InvoiceStatus
}

export interface Trade {
  amount_base: number
  amount_quote: number
  base: CurrencyCurrency
  create_time: string
  id: string
  quote: CurrencyCurrency
  rate: number
  side: OrderSide
  status: TradeStatus
  /**
   * what (if any) transaction this trade relates to.
   */
  transaction_id?: string
}

/**
 * The valid sides for a trade. Used in getting a RFQ (request for quote), and
 * creating and describing trades.
 *
 *  - TRADE_FAILED: The trade could not be completed.
 *  - TRADE_ACCEPTED: The OTC desk has accepted the order.
 */
export type TradeStatus = 'TRADE_FAILED' | 'TRADE_ACCEPTED'

export interface Transaction {
  account_id: string
  amount_bitcoin: number
  amount_satoshi: string
  /**
   * The URL, if any, to send updates to whenever events related to this
   * transaction occurs.
   */
  callback_url: string
  client_id: string
  create_time: string
  description: string
  direction: TransactionDirection
  id: string
  invoice_id?: string
  network_fee_bitcoin: number
  network_fee_satoshi: string
  network_type: NetworkType
  status: TransactionStatus
}

/**
 * - INCOMING: Received to Teslacoil, a deposit
 *  - OUTGOING: Sent from Teslacoil, a withdrawal
 */
export type TransactionDirection = 'INCOMING' | 'OUTGOING'

/**
 * - PENDING: The transaction has not reached a conclusion whether it's completed or
 * failed yet
 *  - COMPLETED: The transaction has been received by the recipient, and is settled.
 *  - FAILED: The transaction has failed
 */
export type TransactionStatus = 'PENDING' | 'COMPLETED' | 'FAILED'

export interface UpdateAccessRequest {
  new_permissions?: Permissions
  user_id?: string
}

export interface UpdateAccountRequest {
  new_auto_exchange_currency?: FiatcurrencyFiatCurrency
  new_name?: string
  new_permissions?: Permissions
}

export interface UpdateUserRequest {
  first_name?: string
  last_name?: string
  preferred_display_currency?: CryptoCurrencyFormat
}

/**
 * Response from the usage endpoint.
 */
export interface UsageResponse {
  /**
   * How many invoices have been created.
   */
  invoice_count: number
  settlement_count: number
  /**
   * How many trades have been created.
   */
  trade_count: number
  /**
   * How many transactions have been created.
   */
  transaction_count: number
}

export interface User {
  email: string
  first_name: string
  id: string
  last_name: string
  preferred_crypto_display_currency: CryptoCurrencyFormat
}

/**
 * ISO 4217: alpha 3-letter e.g EUR, BTC.
 *
 *  - BTC: BTC is the ticker for bitcoin
 *  - SAT: SAT is the smallest denominator of 1 BTC, and is equal to 1/100_000_000
 * of 1 BTC.
 */
export type CurrencyCurrency = 'BTC' | 'SAT' | 'GBP' | 'NOK' | 'USD' | 'EUR'

export type FiatcurrencyFiatCurrency = 'GBP' | 'NOK' | 'USD' | 'EUR'

const buildURL = (route: string, ...args: [string, string | number | undefined | boolean][]): string => {
  let url = route
  let params = ''
  args.forEach(arg => {
    const name = arg[0]
    const value = arg[1]
    if (value) {
      if (params === '') {
        params += `?${name}=${value}`
      } else {
        params += `&${name}=${value}`
      }
    }
  })
  return `${url}${params}`
}

export const Accounting_NodeAudit = async (start_time?: string, end_time?: string): Promise<NodeAuditResponse> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.get(
      buildURL('/v0/accounting/audit/node', ['start_time', start_time], ['end_time', end_time])
    )
    return response.data as NodeAuditResponse
  } catch (error) {
    throw Error(error)
  }
}

export const Accounting_GetStatement = async (start_time?: string, end_time?: string): Promise<Statement> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.get(
      buildURL('/v0/accounting/statement', ['start_time', start_time], ['end_time', end_time])
    )
    return response.data as Statement
  } catch (error) {
    throw Error(error)
  }
}

export const Accounts_Get = async (): Promise<Account> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.get(buildURL('/v0/accounts'))
    return response.data as Account
  } catch (error) {
    throw Error(error)
  }
}

export const Accounts_Create = async (req: CreateAccountRequest): Promise<Account> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.post('/v0/accounts', req)
    return response.data as Account
  } catch (error) {
    throw Error(error)
  }
}

export const Accounts_Update = async (req: UpdateAccountRequest): Promise<Account> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.put('/v0/accounts', req)
    return response.data as Account
  } catch (error) {
    throw Error(error)
  }
}

export const Accounts_RemoveAccess = async (user_id?: string): Promise<{}> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.delete(buildURL('/v0/accounts/access', ['user_id', user_id]))
    return response.data as {}
  } catch (error) {
    throw Error(error)
  }
}

export const Accounts_UpdateAccess = async (req: UpdateAccessRequest): Promise<{}> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.post('/v0/accounts/access', req)
    return response.data as {}
  } catch (error) {
    throw Error(error)
  }
}

export const Accounts_GiveAccess = async (req: GiveAccessRequest): Promise<{}> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.put('/v0/accounts/access', req)
    return response.data as {}
  } catch (error) {
    throw Error(error)
  }
}

export const Accounts_List = async (): Promise<ListAccountsResponse> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.get(buildURL('/v0/accounts/list'))
    return response.data as ListAccountsResponse
  } catch (error) {
    throw Error(error)
  }
}

export const Accounts_ListAccountNames = async (): Promise<ListAccountNamesResponse> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.get(buildURL('/v0/accounts/names'))
    return response.data as ListAccountNamesResponse
  } catch (error) {
    throw Error(error)
  }
}

export const Accounts_GetUserInfo = async (user_id?: string): Promise<AccountUser> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.get(buildURL('/v0/accounts/user', ['user_id', user_id]))
    return response.data as AccountUser
  } catch (error) {
    throw Error(error)
  }
}

export const Exchange_ListSettlements = async (): Promise<ListSettlementsResponse> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.get(buildURL('/v0/exchange/settlements/list'))
    return response.data as ListSettlementsResponse
  } catch (error) {
    throw Error(error)
  }
}

export const Exchange_CreateTrade = async (req: CreateTradeRequest): Promise<Trade> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.post('/v0/exchange/trades', req)
    return response.data as Trade
  } catch (error) {
    throw Error(error)
  }
}

export const Exchange_ListTrades = async (
  offset?: number,
  limit?: number,
  max_satoshi?: string,
  min_satoshi?: string,
  start_time?: string,
  end_time?: string,
  sort: 'DESCENDING' | 'ASCENDING' = 'DESCENDING',
  side?: string
): Promise<ListTradesResponse> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.get(
      buildURL(
        '/v0/exchange/trades/list',
        ['offset', offset],
        ['limit', limit],
        ['max_satoshi', max_satoshi],
        ['min_satoshi', min_satoshi],
        ['start_time', start_time],
        ['end_time', end_time],
        ['sort', sort],
        ['side', side]
      )
    )
    return response.data as ListTradesResponse
  } catch (error) {
    throw Error(error)
  }
}

export const Experimental_GetLNURLWithdrawal = async (secret?: string): Promise<LNURLWithdrawResponse> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.get(buildURL('/v0/experimental/lnurl/withdraw', ['secret', secret]))
    return response.data as LNURLWithdrawResponse
  } catch (error) {
    throw Error(error)
  }
}

export const Experimental_CompleteLNURLWithdrawal = async (
  k1?: string,
  pr?: string,
  transaction_callback_url?: string
): Promise<CompleteLNURLWithdrawResponse> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.get(
      buildURL(
        '/v0/experimental/lnurl/withdraw/complete',
        ['k1', k1],
        ['pr', pr],
        ['transaction_callback_url', transaction_callback_url]
      )
    )
    return response.data as CompleteLNURLWithdrawResponse
  } catch (error) {
    throw Error(error)
  }
}

export const Experimental_CreateLNURLWithdrawal = async (
  req: CreateLNURLWithdrawRequest
): Promise<CreateLNURLWithdrawResponse> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.post('/v0/experimental/lnurl/withdraw/create', req)
    return response.data as CreateLNURLWithdrawResponse
  } catch (error) {
    throw Error(error)
  }
}

export const Invoices_Get = async (
  id?: string,
  transaction_id?: string,
  address?: string,
  lightning_request?: string
): Promise<Invoice> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.get(
      buildURL(
        '/v0/invoices',
        ['id', id],
        ['transaction_id', transaction_id],
        ['address', address],
        ['lightning_request', lightning_request]
      )
    )
    return response.data as Invoice
  } catch (error) {
    throw Error(error)
  }
}

export const Invoices_Create = async (req: CreateInvoiceRequest): Promise<Invoice> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.post('/v0/invoices', req)
    return response.data as Invoice
  } catch (error) {
    throw Error(error)
  }
}

export const Invoices_List = async (
  offset?: number,
  limit?: number,
  max_amount?: number,
  min_amount?: number,
  currency?: string,
  start_time?: string,
  end_time?: string,
  type?: string,
  payment_status?: string,
  transactions_count?: number,
  paid_before_expiry?: boolean,
  expired?: boolean,
  sort_direction: 'DESCENDING' | 'ASCENDING' = 'DESCENDING'
): Promise<InvoiceList> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.get(
      buildURL(
        '/v0/invoices/list',
        ['offset', offset],
        ['limit', limit],
        ['max_amount', max_amount],
        ['min_amount', min_amount],
        ['currency', currency],
        ['start_time', start_time],
        ['end_time', end_time],
        ['type', type],
        ['payment_status', payment_status],
        ['transactions_count', transactions_count],
        ['paid_before_expiry', paid_before_expiry],
        ['expired', expired],
        ['sort_direction', sort_direction]
      )
    )
    return response.data as InvoiceList
  } catch (error) {
    throw Error(error)
  }
}

export const Stats_AmountTransacted = async (
  start_time?: string,
  end_time?: string,
  currency?: string
): Promise<AmountTransactedResponse> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.get(
      buildURL(
        '/v0/stats/amount_transacted',
        ['start_time', start_time],
        ['end_time', end_time],
        ['currency', currency]
      )
    )
    return response.data as AmountTransactedResponse
  } catch (error) {
    throw Error(error)
  }
}

export const Stats_RecentEvents = async (): Promise<RecentEventsResponse> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.get(buildURL('/v0/stats/recent_events'))
    return response.data as RecentEventsResponse
  } catch (error) {
    throw Error(error)
  }
}

export const Stats_Usage = async (start_time?: string, end_time?: string): Promise<UsageResponse> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.get(buildURL('/v0/stats/usage', ['start_time', start_time], ['end_time', end_time]))
    return response.data as UsageResponse
  } catch (error) {
    throw Error(error)
  }
}

export const TeslaPay_Get = async (id?: string): Promise<TeslaPayInvoice> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.get(buildURL('/v0/teslapay', ['id', id]))
    return response.data as TeslaPayInvoice
  } catch (error) {
    throw Error(error)
  }
}

export const Transactions_GetTransaction = async (id?: string, client_id?: string): Promise<Transaction> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.get(buildURL('/v0/transactions', ['id', id], ['client_id', client_id]))
    return response.data as Transaction
  } catch (error) {
    throw Error(error)
  }
}

export const Transactions_GetLightning = async (
  id?: string,
  lightning_request?: string
): Promise<LightningTransaction> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.get(
      buildURL('/v0/transactions/lightning', ['id', id], ['lightning_request', lightning_request])
    )
    return response.data as LightningTransaction
  } catch (error) {
    throw Error(error)
  }
}

export const Transactions_DecodeLightning = async (lightning_request?: string): Promise<DecodeLightningResponse> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.get(
      buildURL('/v0/transactions/lightning/decode', ['lightning_request', lightning_request])
    )
    return response.data as DecodeLightningResponse
  } catch (error) {
    throw Error(error)
  }
}

export const Transactions_SendLightning = async (req: SendLightningRequest): Promise<SendTransactionResponse> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.post('/v0/transactions/lightning/send', req)
    return response.data as SendTransactionResponse
  } catch (error) {
    throw Error(error)
  }
}

export const Transactions_ListTransactions = async (
  offset?: number,
  limit?: number,
  max_satoshi?: string,
  min_satoshi?: string,
  start_time?: string,
  end_time?: string,
  direction?: string,
  sort: 'DESCENDING' | 'ASCENDING' = 'DESCENDING',
  network_type?: string,
  status?: string,
  include_settlements?: boolean
): Promise<ListTransactionsResponse> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.get(
      buildURL(
        '/v0/transactions/list',
        ['offset', offset],
        ['limit', limit],
        ['max_satoshi', max_satoshi],
        ['min_satoshi', min_satoshi],
        ['start_time', start_time],
        ['end_time', end_time],
        ['direction', direction],
        ['sort', sort],
        ['network_type', network_type],
        ['status', status],
        ['include_settlements', include_settlements]
      )
    )
    return response.data as ListTransactionsResponse
  } catch (error) {
    throw Error(error)
  }
}

export const Transactions_GetOnchain = async (id?: string, client_id?: string): Promise<OnchainTransaction> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.get(buildURL('/v0/transactions/onchain', ['id', id], ['client_id', client_id]))
    return response.data as OnchainTransaction
  } catch (error) {
    throw Error(error)
  }
}

export const Transactions_SendOnchain = async (req: SendOnchainRequest): Promise<SendTransactionResponse> => {
  if (apiKey === '') {
    throw Error(apiKeyNotSetMessage)
  }

  try {
    const response = await api.post('/v0/transactions/onchain/send', req)
    return response.data as SendTransactionResponse
  } catch (error) {
    throw Error(error)
  }
}
